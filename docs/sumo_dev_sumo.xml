<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
  <bookinfo>
    <title>SUMO developer documentation</title>
    <author>
      <firstname>Christian</firstname>
      <surname>R&ouml;ssel</surname>
      <affiliation>
        <address><email>christian.roessel@dlr.de</email></address>
      </affiliation>
    </author>
    <author>
      <firstname>Daniel</firstname>
      <surname>Krajzewicz</surname>
      <affiliation>
        <address><email>daniel.krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>

  </bookinfo>

  <toc>
  </toc>


  <chapter>
    <title>Detectors</title>

    <para>In the following sections we will describe SUMOs way to
    communicate with it's two kinds of detectors, the <link
    linkend="ExtendedDetectors"><emphasis>extended</emphasis></link>
    ones, that work on an area of a lane and the <link
    linkend="UnextendedDetectors"><emphasis>unextended</emphasis></link>
    ones, that measure at a fixed position on a lane.</para>

    <sect1 id="DetectorCommunication">
      <title>Communication between detectors and SUMO</title>

      <para>Detectors are nearly independant from the rest of the
      simulation. In the simulation loop there is just on call to a
      static method before the emission and the move of the vehicles,
      and one call afterwards. The moving vehicles inform the
      detectors that they have entered or left the detector through
      <emphasis>move-reminder</emphasis>-objects. These move-reminders
      have to be provided for each detector. They are instances of
      small classes, that just check for some condition, e.g. the
      position of the vehicle (you can check for whatever a vehicle
      provides). All move-reminders inherit from
      <literal>MSMoveReminder</literal>. If a condition is met, the
      reminder informs the detector. All data is collected in the
      detector-object. And all processing is done there, too. So if
      you want a special purpose detector, you have to write the
      detector-class and a corresponding reminder-class.</para>

      <para>But how do the vehicles know about the move-reminders? On
      creation of a detector object, a reminder-object is created
      too. It is passed to the lane the detector works on. The lane
      has a container of move-reminder objects. If a vehicle enters a
      lane it gets a copy of this container. At every move, the
      vehicle calls the method
      <literal>workOnMoveReminders()</literal>. In this call all
      reminders are asked if they are
      <literal>isStillActive()</literal>. If not, they are removed from
      the vehicles move-reminder container, otherwise the detector may
      be called. The move-reminders have just two additional methods
      for entering and leaving the lane. Their names are quite
      self-explanatory:
      <literal>isActivatedByEmitOrLaneChange()</literal> and
      <literal>dismissByLaneChange()</literal>.</para>

      <para>Note that the interfaces of detector classes may differ
      completely. The detector methods that collect data are called by
      their associated reminders only. There is no need to inherit
      from a base detector.</para>

      <para>The following <link
      linkend="DetectorCollaboration">UML-diagram</link> shows the
      classes and methods that are relevant for the proper operation
      of the <literal>MSLaneState</literal> detector. </para>


      <mediaobject id="DetectorCollaboration" >
	<imageobject>
	  <imagedata fileref="images/DetectorCollaboration.eps" format="EPS"/>
	</imageobject>
	<imageobject>
	  <imagedata fileref="images/DetectorCollaboration.png" format="PNG"/>
	</imageobject>
	<caption>
	  <para>Classes and methods used for collabaration between
	  <literal>MSLaneState</literal> detector and the rest of the
	  simulation.</para>
	</caption>
      </mediaobject>



    </sect1>

    <sect1 id="ExtendedDetectors">
      <title>Extended detectors</title>

      <para>In real life the <emphasis>extended</emphasis> detectors
      are realized by headover detectors, like video-cameras on
      helicopters, bridges, zeppelins. They collect data from an area
      of a lane. They are ideal to measure
      <emphasis>densities</emphasis>, because densities are
      area-measured quantities. They are also the first choice to
      measure <link linkend="TravelcostDetectors">
      <emphasis>travelcosts</emphasis> </link>. In this case the
      extended detector covers the lane completely. Sophisticated
      <emphasis>traffic-signal sequencing</emphasis> depends also on
      extended detectors.</para>

      <sect2>
	<title>The <literal>MSLaneState</literal> detector</title>

	<para>Currently there is only one extended detector:
        <literal>MSLaneState</literal>. This detector covers a part of
        a lane and collects basic vehicle data, like speed, entry- and
        leavetime. It provides following methods to get information
        about the current state of the detector:</para>

	<itemizedlist>
	  <listitem>
	    <literallayout><literal>int getCurrentNumberOfWaiting( void )</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getCurrentMeanSpeed( void );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getCurrentMeanSpeedSquare( void );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getCurrentDensity( void );</literal></literallayout>
	  </listitem>
	</itemizedlist>

	<para>To get averaged detector data (averaged over
      <literal>lastNTimesteps</literal>) you can call the following
      methods:</para>

	<itemizedlist>
	  <listitem>
	    <literallayout><literal>double getNumberOfWaiting( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getMeanSpeed( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getMeanSpeedSquare( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getMeanDensity( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>double getMeanTraveltime( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>int getNVehContributed( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>int getNVehEnteredDetector( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>int getNVehLeftDetectorByMove( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>int getNVehPassedEntireDetector( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>std::string getXMLOutput( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	</itemizedlist>

	<note>
	  <para>Note that there is a upper limit for
	  <literal>lastNTimesteps</literal>. In order to save memory,
	  the collected data is stored for a bounded interval
	  only. You can adjust this bound through the
	  <literal>MSLaneState</literal> constructor-parameter
	  <literal>deleteDataAfterSeconds</literal>. The default is 15
	  minutes. The deletion is triggerd by
	  <literal>MSEventControl</literal>.</para>
	</note>

	<para>For more details on this class see the files
        <literal>MSLaneState.h</literal> and
        <literal>MSLaneState.cpp</literal>.</para>

      </sect2>

      <sect2 id="TravelcostDetectors">
	<title>Extended detectors as travelcost detectors</title>

	<para>If you want to measure travelcosts, you usually put an
	extended detector on every lane, aggregate the collected data
	over a fixed interval and write this data to a file. This is,
	what <literal>MSTravelcostDetector</literal>
	provides. <literal>MSTravelcostDetector</literal> is a
	template singleton class. The template parameter is the
	extended detector to use. So if you call
	<literal>MSTravelcostDetector&lt; MSLaneState &gt;::create(
	maxIntervalLength )</literal>
	<literal>MSTravelcostDetector</literal> creates
	<literal>MSLaneState</literal> detectors on every lane,
	covering the lanes completety. Then you can add sample
	intervals from 1 to maxIntervalLength seconds (call
	e.g. <literal>MSTravelcostDetector&lt; MSLaneState
	&gt;::getInstance()->addSampleInterval( 60 )</literal>, which
	adds a 60 seconds interval. The collected data will be written
	in a file called <literal>MSLaneState_60.xml</literal>).
	</para>

	<para>The sampling for a specific interval is triggered by
	<literal>MSEventControl</literal>.</para>

	<para>An extended detector class must provide following
	methods to be a proper template parameter to
	<literal>MSTravelcostDetector</literal>:</para>

	<itemizedlist>
	  <listitem>
	    <literallayout><literal>static std::string getNamePrefix( void );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>static std::string&amp; getXMLHeader( void );</literal></literallayout>
	  </listitem>
	  <listitem>
	    <literallayout><literal>std::string getXMLOutput( MSNet::Time lastNTimesteps );</literal></literallayout>
	  </listitem>
	</itemizedlist>

	<para>For an example see <literal>MSLaneState</literal>.</para>

      </sect2>

    </sect1>


    <sect1 id="UnextendedDetectors">
      <title>Unextended detectors</title>

      <para>The real life counterpart of <emphasis>unextended
      detectors</emphasis> are induction loops. They collect data from
      a fixed position on a lane when a vehicle passes by. They are
      predestined for <emphasis>flow measurments</emphasis>. </para>

      <note>
	<para>The MSinductionLoop class has to be modified to use the
	move-reminder concept. The documentation will be added if this
	task is completed.</para>
      </note>

    </sect1>
  </chapter>

</book>




