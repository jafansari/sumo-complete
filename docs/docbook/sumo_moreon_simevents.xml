<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title id="more_events">SUMO - More on... Events within the
    Simulation</title>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="more_events-intro">
    <title>Introduction</title>

    <sect1>
      <title>Document Information</title>

      <para>This document is a part of <emphasis>SUMO</emphasis> -
      <emphasis>S</emphasis>imulation of <emphasis>U</emphasis>rban
      <emphasis>MO</emphasis>bility. SUMO is an open source microscopic road
      traffic simulation. It can be found under <ulink
      url="http://sumo.sourceforge.net/">http://sumo.sourceforge.net/</ulink>.</para>

      <para>This document fits to version 0.9.5. We will try to keep it
      up-to-date with the next versions.</para>
    </sect1>

    <sect1>
      <title>Document Scope</title>

      <para>Being the main part of the simulation, the vehicles running
      through the network are touched every simulation step. But there are
      also other structures which actions have to be run only at some certain
      times. Examples for this may be traffic lights which switch only each
      some seconds or trigger for switching a vehicle device into another
      state. In order to avoid checking all those structures each time step,
      the simulation module contains a storage for "Events". This concept will
      be described within this document more deeply.</para>
    </sect1>

    <sect1>
      <title>Document Audience</title>

      <para>This document contains information for
      <emphasis>developers</emphasis> who want to extend SUMO by own
      structures which do not need to be touched in each simulation
      step.</para>
    </sect1>

    <sect1>
      <title>Document Structure</title>

      <para>!!!.</para>
    </sect1>
  </chapter>

  <chapter id="more_events-events">
    <title>The Events</title>

    <sect1>
      <title>A Basic Event</title>

      <para>The base of all events looks like this (from
      <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/utils/helpers/Command.h</filename>):</para>

      <programlisting>class Command
{
public:
    Command() { }

    <remark>/// Destructor.</remark>
    virtual ~Command() { }

<remark>    /**
     * @brief Executes the command.
     *
     * @param currentTime The current simulation time
     *
     * @return The receivers operation should return the next interval
     * in steps for recurring commands and 0 for single-execution
     * commands.
     */
</remark>    virtual SUMOTime execute(SUMOTime currentTime) = 0;

};</programlisting>

      <para>What you have here is an interface which offers you to define your
      own functions for what to do if the event will be executed. As you can
      see, the method gets the current simulation time what should be quite
      handy and returns another time value. The returned time value must be
      the time after which this event shall be called again. If 0 (zero) or a
      value lesser than zero is returned, this event will be descheduled and
      not called again. Also, this event will be deleted by the event
      handler.</para>
    </sect1>

    <sect1>
      <title>Inserting an Event into the Simulation</title>

      <para>Events can be stored into the handler at any time. When stored,
      the time the event shall be executed for the first time within the
      simulation must be added and an information about what to do if this
      time lies before the simulation begin. The call which adds an event to
      the handler is (from
      <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/microsim/MSEventControl.h</filename>):</para>

      <programlisting><remark>    /** @brief Adds an Event.
     *
     * Returns the time the event will be executed, really */
</remark>    SUMOTime addEvent( Command* operation, SUMOTime execTimeStep, AdaptType type );</programlisting>

      <para>There are two event handlers within the simulation, one for events
      that shall be executed at the begin of a simulation step and one for
      those that shall be executed at the end of a simulation step. You can
      access them from the network - which is build before the loading begins,
      so that it can be accessed at any time (see !!!). To retrieve the event
      handlers from the net, you can get the net-singleton using:</para>

      <programlisting>MSNet *net = MSNet::getInstance();</programlisting>

      <para>Then you can get references to the event handlers using:</para>

      <programlisting>MSEventControl &amp;timestepBeginEvents = net-&gt;getBeginOfTimestepEvents();
MSEventControl &amp;timestepEndEvents = net-&gt;getEndOfTimestepEvents();</programlisting>

      <para>If the time you have given for the execution time is after the
      simulation's begin, nothing will be done. But sometimes, one may define
      event times (for example for TLS switch) for the whole day but let the
      simulation start at 6am. So you have to deal with the problem that the
      given execution times may be before the simulation begin. To deal with
      this, there are two time adaptations possible by now (defined in
      <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/microsim/MSEventControl.h</filename>):</para>

      <programlisting><remark>    /**
     * @enum AdaptType
     * Defines what to do if the insertion time lies before the current simulation
     *  time
     */
</remark>    enum AdaptType {
<remark>        /// Patch the time in a way that it is at least as high as the
        /// simulation begin time
</remark>        ADAPT_AFTER_EXECUTION = 1,
        <remark>/// Do nothing</remark>
        NO_CHANGE = 2
    };</programlisting>

      <para>When passed, ADAPT_AFTER_EXECUTION will set the event execution
      time to the first simulation time step plus one (!!!), NO_CHANGE will
      leave the execution time as it is - but you should keep in mind that
      this may be before the simulation begin.</para>
    </sect1>

    <sect1>
      <title>The Lifecycle of an Event</title>

      <para>!!!</para>
    </sect1>

    <sect1>
      <title>Event Variants</title>

      <para>We have described that an event is deleted by the event handler as
      soon as it is no longer valid or if the simulation ends. Now, you maybe
      want to write a class which represents a structure</para>

      <sect2>
        <title>WrappingCommand</title>

        <para>We have described that an event is deleted by the event handler
        as soon as it is no longer valid or if the simulation ends. Now, you
        maybe want to write a class which represents a structure that must be
        called by the event handler from time to time. If you would add such a
        structure into the event handler directly, it ill be deleted by him.
        If you want to avoid this, you can use an event which encapsulates the
        call to your strutcure. Such an event is the WrappingCommand-class
        (defined in
        <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/utils/helpers/WrappingCommand.h</filename>).
        This class simply wraps a call to a method
        <function><returnvalue>SUMOTime</returnvalue>
        <methodname>foo</methodname>(<parameter>SUMOTime</parameter>)</function>.</para>

        <para>If you have a class named <classname>Bar</classname> which has
        the method <function><returnvalue>SUMOTime</returnvalue>
        <methodname>foo</methodname>(<parameter>SUMOTime</parameter>)</function>,
        you can build an event which will call an instance of
        <classname>Bar</classname> (named <varname>barInstance</varname>
        herein) as following:</para>

        <programlisting>Command *event = new WrappingCommand&lt;Bar&gt;(barInstance, &amp;Bar::foo)</programlisting>
      </sect2>

      <sect2>
        <title>One...Command</title>

        <para>!!!</para>
      </sect2>

      <sect2>
        <title>DiscreteCommand</title>

        <para>!!!</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id="more_events-handler">
    <title>The Event Handler(s)</title>

    <sect1>
      <title>How an EventHandler works</title>

      <para>The event handlers are members of <classname>MSNet</classname> and
      are build as soon as the network is created, that means before the
      configuration is processed. That means, one can store new events during
      the loading process already and also during the simulation. When added,
      an event is stored together with the (possibly adapted) execution time
      in a priority_queue which is sorted by the execution time.</para>

      <para>During a simulation step, <classname>MSNet</classname> calls the
      method <function><returnvalue>void</returnvalue>
      MSEventControl::<function>execute</function>(<parameter>SUMOTime</parameter>)</function>
      for both handlers. At the begin of the simulation step, the net calls
      this method for his <varname>myBeginOfTimestepEvents</varname>-handler,
      at the end for his <varname>myEndOfTimestepEvents</varname>-handler.
      Each of this calls forces the called handler to go through all events
      that shall be executed within the given time step and prior to this. If
      the execution time of an event is before the current simulation step,
      this event will be deleted! (!!!). Otherwise - the execution time and
      the time step are the same - the event is executed and returns the time
      till next call. If no next call is wanted, zero should be returned. In
      this case, the event will be deleted.</para>

      <para>When the simulation network is deleted, all remaining events are
      deleted, too.</para>
    </sect1>

    <sect1>
      <title>Lifecycle of an EventHandler</title>

      <para>!!!</para>
    </sect1>
  </chapter>
</book>