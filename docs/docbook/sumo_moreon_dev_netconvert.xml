<?xml version="1.0" encoding="UTF-8"?>
<book>
  <bookinfo>
    <title>SUMO developer documentation</title>

    <author>
      <firstname>Christian</firstname>

      <surname>RÃ¶ssel</surname>

      <affiliation>
        <address><email>christian.roessel@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="dev_chp04">
    <title>Netconvert</title>

    <sect1>
      <title>Introduction</title>

      <sect2>
        <title>Why netconversion?</title>

        <para>There are two reasons why we decided to build SUMO-networks by
        converting ones existing in other formats. The first is that our
        interest mainly lies on simulation of large urban areas and the
        networks size speaks against inserting and editing them by hand. The
        second is the high complexity of the SUMO-network format allowing
        minimum effort on post-processing the data after loading it within the
        simulation. Using this approach, the amount of memory used within the
        simulation is reduced.</para>
      </sect2>

      <sect2>
        <title>Features of SUMO-NETCONVERT</title>

        <para><itemizedlist>
            <listitem>
              <para>Computation of lane to lane connections</para>
            </listitem>

            <listitem>
              <para>Computation of traffic lights</para>
            </listitem>
          </itemizedlist></para>
      </sect2>
    </sect1>

    <sect1>
      <title>Netconversion-Process description</title>

      <para>The process of building networks from loaded data max be splitted
      into steps as shown within the next picture. We will not describe how
      options are parsed within this document; a further one should be
      available about this topic as this process is common to all modules. The
      further steps are described within the next subsect1s.</para>

      <figure>
        <title>Process of network building</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="./gfx/dev/mainflow.gif"
                       format="GIF" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect2>
        <title>Data Loading</title>

        <para>... to be described...</para>
      </sect2>

      <sect2>
        <title>Data Processing</title>

        <para>After each loader has finished, the data should be stored within
        the container classes "NB*Cont" the same way. Now, the process of
        conversion into the SUMO-format, possibly including some computation
        of further needed values, takes place. You may ask why we do need
        eleven steps (version 0.8) to post process the data. Here is the list
        of actions done and their explanation, too.</para>

        <orderedlist>
          <listitem>
            <para>Removing dummy edges</para>

            <para>Is only needed within Vissim; Here, sometimes edges fall
            completely into a junction. We do not consider them and they are
            removed from the container within this step.</para>
          </listitem>

          <listitem>
            <para>Joining double connections</para>

            <para>Within Vissim, two edges may join the same nodes into the
            same direction. Being practically different lanes and not
            different streets, these node connections are joined into a single
            edge.</para>
          </listitem>

          <listitem>
            <para>Computing turning directions</para>

            <para>For each edge known within NBEdgeCont, the opposite edge is
            computed. They are left unseen for the next steps and later
            assigned as the turning direction. An edge is regarded as being
            the turning direction if it yields in the same node the current
            edge springs off.</para>
          </listitem>

          <listitem>
            <para>Sorting nodes' edges</para>

            <para>For each node known by NBNodeCont, the 3 lists, being
            unsorted so far are sorted: _incoming, _outgoing and _allEdges. By
            doing this, we later know the abstract geometrical relationships
            between edges (which edge is right to which etc.). The lists are
            sorted clockwise beginning at the edge coming from the most
            northern direction.</para>
          </listitem>

          <listitem>
            <para>Node position normalisation</para>
          </listitem>

          <listitem>
            <para>Edge to Edge - relationship computation</para>

            <para>For each edge, the list of edges that may be approached from
            it is being computed and which of this edge's lanes are used to do
            this. It is not yet computed, which of this edge's lanes
            approaches which lanes.</para>

            <para>We describe this process more detailed in one of the next
            subsections.</para>
          </listitem>
        </orderedlist>

        <para>Before the loaded data may be processed, their container must be
        informed about the end of the loading. By now, this is only true for
        the nodes as the edges do not need any pre-processing. The method
        <methodname>NBNodeCont::close()</methodname> is called from
        <methodname>NBLoader::load()</methodname> to precompute the nodes. A
        further description will be given in the next subsection.</para>

        <para>The computation of data itself is consists of two steps. In the
        first step (<methodname>computeEdges()</methodname>) the connections
        between edges are computed. The second step
        (<methodname>computeNodes()</methodname>) is generating the junction
        logics for the connecting nodes (junctions). During this part of the
        process, the program will terminate when errors are encountered. This
        is done by propagating a thrown ProcessError instance. ProcessError is
        indirectly derived from exception and may be found in
        <filename>utils/UtilExceptions.h</filename>.</para>

        <sect3>
          <title>Sorting nodes' edges</title>

          <para>An edges angle is compute on construction as the origin and
          the destination nodes are known, here. <caution>
              <para>What about the edge's geometry?</para>
            </caution>Still, the angle of course depends on whether it is an
          incoming or an outgoing edge. The
          NBContHelper::edge_by_junction_angle_sorter()-method does consider
          this by checking which type of an edge (incoming or outgoing) the
          current edge is and converts the angles of incoming edges by turning
          them around 180 degree.</para>

          <para>Keep in mind, that our coordinates are as described within the
          user-documentation, the higher a point shall be, the greater his
          y-value, the more to left, the higher his x-value.</para>

          <para>It is not assured, that the incoming and outgoing directions
          of a northern street are lying beside each other within the list of
          sorted edges. It may rather be, that the outgoing is lying at the
          begin and the incoming at the end.</para>
        </sect3>

        <sect3>
          <title>Computation of edge to edge - relationships</title>

          <para>For each edge, the following is being done: At first, the list
          of edges outgoing from the junction this edge yields in is
          retrieved. Then, the importance of each connected edge is being
          computed using the priority of the approached edge. This means that
          more important roads are being approached by a higher number of
          lanes.</para>
        </sect3>
      </sect2>

      <sect2>
        <title>NBNodeCont::close()</title>

        <para>Like most of the container methods, this method only invokes a
        method with the same name (here: <methodname>close()</methodname>) on
        all of the classes stored inside it. The so invoked method
        NBNode::close() computes the node's lists of edges. Each node has
        three lists:</para>

        <itemizedlist>
          <listitem>
            <para><type>std::vector&lt;NBEdge*&gt;</type>
            <varname>_allEdges</varname> holds both the incoming and the
            outgoing edges sorted clockwise beginning with the edge(s) at the
            node's north side (0 degree). Please remark, that this of course
            may be more than one edge as for instance both the incoming and
            the outgoing edge may be found here. Additionally, the edges are
            sorted in the continental way - that means the traffic is assumed
            to be on the right side. The next figure shows a very simple
            junction and the used sort order.</para>
          </listitem>

          <listitem>
            <para><type>std::vector&lt;NBEdge*&gt;*</type>
            <varname>_incomingEdges</varname> which the edges that yield into
            the junction sorted as described above.</para>
          </listitem>

          <listitem>
            <para><type>std::vector&lt;NBEdge*&gt;*</type>
            <varname>_outgoingEdges</varname> which the edges that originate
            at the current junction.</para>
          </listitem>
        </itemizedlist>

        <para>Additionally, this method also computes the type of the
        junction, as all needed nodes are already known. As this also involves
        the setting of the junction priorities the participating edges have
        and we will discuss these computations more briefly now.</para>
      </sect2>

      <sect2>
        <title>Computation of Edge Connections</title>

        <para>In SUMO each edge may be connected to some following edges. The
        simulation does not need the names of the connected edges only, but
        also two other information: a) for each of an edge's lanes, the
        "succeeding" (reachable) lanes must be given b) the edge must know,
        which of her lanes may be used to reach a special following
        edge.</para>

        <para>In fact, the data are quite similar, only the key/value -
        relationship paradigm changes. Still, there is another problem that is
        more interesting. It is the computation of a lane's following
        lanes.</para>

        <para>As input, we have a net made up from junctions and edges where
        each edge consists of at least one lane. Let's take a look at a single
        junction where the edge we want to compute is marked by
        shading:</para>

        <para>The easiest way in this case would be to let vehicles on the
        left lane drive to the left; the vehicles on the right lane drive to
        the right and the vehicles on the middle lane drive ahead. Still, some
        junctions may occur where the number of lanes does not match the
        number of possible directions.</para>

        <para>By now, we are using the simple approach to distribute the
        incoming lanes uniformly on the outgoing lanes. Additionally, before
        this computation, we remove the opposite direction from the list of
        approachable lanes and add this connection afterwards:</para>

        <para>This makes the job quite good, but still has a problem. As one
        can see in the next picture, the situation in real life is, that
        vehicles driving on the right lane may turn right or drive ahead.
        Still, our approach allows the turning only:</para>
      </sect2>

      <sect2>
        <title>computeNodes() : Computation of a Junction Logic</title>

        <para>A junction should always consist of more than two streets where
        a street is a directed connection between two points. Streets may have
        different priorities and vehicles driving on roads that have a lower
        priority should wait for those driving on roads with a higher
        priority. Even when the streets that build up a junction have the same
        priority, the further movement of the cars is determined by the
        right-of-way - rule "left before right" - at least in countries where
        driving on the right side of the road is used. All these circumstances
        make a logic for a junction necessary that decides which vehicles may
        move and which not. Within SUMO, such a logic gets an input vector of
        booleans which represents all possible movements (connections between
        an incoming lane and an outgoing lane) where a set value represents a
        vehicle that wishes to use this connection. The connections themselves
        were previously computed by the "computeEdges()" - method. The output
        of a logic is a vector of booleans, too, but the booleans do not
        longer represent possible connections but the lanes that are allowed
        to drive.</para>

        <para>NETCONVERT is responsible for the building of these logics and
        the computeNodes() - method performs this action.</para>

        <para>Inside SUMO you will find two ways of representation for
        junction logics. The first idea was to use a map and store all
        possible combinations together with responses into it. This yielded in
        MSMapLogic. Still, some junctions are too big for this representation,
        so we invented the MSBitfieldLogic. You will find better documentation
        about these classes in [3, 4].</para>

        <para>Both representations are supported by the NETCONVERT. As the
        following diagram shows, during the computation of a single logic, a
        key is computed at first. This key is a unique identifier for the
        junction logic that is currently built. A closer description of the
        key will be given later.</para>
      </sect2>

      <sect2>
        <title>Computation of Logics</title>

        <para>After the key's computation, the program looks into the
        "junction-path" (-j) - folder to determine whether the logic according
        the key was already computed. As the logic's functionality stays the
        same, even when the key is rotated as long as the incoming/outgoing
        edges are rotated in the same way, this method
        (NBJunctionIO::try2convert) returns the number of rotations to be done
        to fit the junction's incoming/outgoing edges information to an
        existing logic. Then, this fitting is done by rotating the key and the
        incoming/outgoing edges and the computation is finished for this
        junction as the logic was already computed. Still, when try2convert
        returns a value below 0, no logic for a junction of this type exists
        yet and must be computed. To avoid the computation of too complex
        MSMapLogics, we determine the number of possible variations of the
        driving wishes that may occur first and compare it to the value
        "map-maxsize" (-m) that may be changed by the user. The map logic is
        computed only when this value is larger than the computed number of
        the logics permutations. Otherwise, the key is converted into a key
        that already indicates the usage of a bitfield logic. This is simply
        done by replacing the key type (the first char of the key) from "a" to
        "b" as no other logic representations are known yet.</para>

        <para>Independent to whether a MSMapLogic was computed or not, the
        MSBitfieldLogic is then computed, so it may be loaded when the other
        logic could not be found or the user wishes the usage of
        MSBitfieldLogics only. Every logic is saved directly after it's
        computation using the NBJunctionIO - class. The resulting key (which
        may be changed from a MapLogic- to a BitfieldLogic-key) is the
        assigned to the junction.</para>
      </sect2>

      <sect2>
        <title>Data Saving</title>

        <para>As the data is all computed by now, it may be saved
        straightforward into a file. As mentioned before, the junction logics
        are already saved, only the net containing the edge/lane-definitions
        and the junction definitions is saved.</para>
      </sect2>
    </sect1>
  </chapter>
</book>