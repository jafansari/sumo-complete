<?xml version="1.0" encoding="UTF-8"?>
<book>
  <bookinfo>
    <title id="howto_global_output">SUMO - HowTo... Add a global output
    File</title>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Benjamin</firstname>

      <surname>Maier</surname>

      <affiliation>
        <address><email>Benjamin.Maier@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Eric</firstname>

      <surname>Nicolay</surname>

      <affiliation>
        <address><email>Eric.Nicolay@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="howto_global_output-intro">
    <title>Introduction</title>

    <sect1 id="howto_global_output-intro-information">
      <title>Document Information</title>

      <para>This document is a part of <emphasis>SUMO</emphasis> -
      <emphasis>S</emphasis>imulation of <emphasis>U</emphasis>rban
      <emphasis>MO</emphasis>bility. SUMO is an open source microscopic road
      traffic simulation. It can be found under <ulink
      url="http://sumo.sourceforge.net/">http://sumo.sourceforge.net/</ulink>.</para>

      <para>This document fits to version 0.9.5. We will try to keep it
      up-to-date with the next versions.</para>
    </sect1>

    <sect1 id="howto_global_output-intro-scope">
      <title>Document Scope</title>

      <para><application>SUMO</application> contains several simulation-wide
      output options which, f.e., collect information from all instances of
      vehicles or streets and save them into a single file. Their
      implementation is hidden between different layers, structures, and
      methods so adding a new output may be not very straightforward. To ease
      the development of such new outputs, this HowTo shows the implementation
      of a new simulation-wide output by example.</para>
    </sect1>

    <sect1 id="howto_global_output-intro-audience">
      <title>Document Audience</title>

      <para>This document contains information for
      <emphasis>developers</emphasis> who want to extend SUMO.</para>
    </sect1>

    <sect1 id="howto_global_output-intro-structure">
      <title>Document Structure</title>

      <para>The first chapter describes what the described extension shall do
      (the goal).</para>

      <para>The second one described how to extend SUMO to achieve the
      goal.</para>
    </sect1>
  </chapter>

  <chapter id="howto_global_output-goal">
    <title>Description of the Goal</title>

    <para>For the TrafficOnline project, vehicles should be equipped with
    cellphones which report their states into an output. The output to
    implement shall be accessable from vehicle devices. Each vehicle may
    contain several devices and all shall write to a single file as soon as an
    event occures or after a given time has passed.</para>
  </chapter>

  <chapter id="howto_global_output-implementation">
    <title>Implementation</title>

    <para>For the TrafficOnline project, vehicles should be equipped with
    cellphones which report their states into an output.</para>

    <sect1 id="howto_global_output-implementation-output_management">
      <title>Output Management within the Simulation</title>

      <para>All simulation-wide outputs are managed by the
      <classname>SUMOFrame</classname> and <classname>MSNet</classname>.
      <classname>MSNet</classname> holds the list of implemented, optional,
      simulation-wide outputs in an enumeration defined in
      <filename>MSNet.h</filename>:</para>

      <programlisting>...
<remark>    /**
     * @enum MSNetOutputs
     * List of network-wide outputs
     */
</remark>    enum MSNetOutputs {
        <remark>/// netstate output</remark>
        OS_NETSTATE = 0,
        <remark>/// emissions output</remark>
        OS_EMISSIONS,
        <remark>/// trip information output</remark>
        OS_TRIPDURATIONS,
        <remark>/// route information output</remark>
        OS_VEHROUTE,
        <remark>/// maximum value</remark>
        OS_MAX
    };
...</programlisting>

      <para>You may notice, that the names of the entries correspond with the
      simulation-wide outputs that were available so far: "netstate",
      "emissions-output", "tripinfo-output", and "vehroute-output". We add our
      new handle to the list changing this part of MSCORN like following,
      first:</para>

      <programlisting>...
<remark>    /**
     * @enum MSNetOutputs
     * List of network-wide outputs
     */
</remark>    enum MSNetOutputs {
        <remark>/// netstate output</remark>
        OS_NETSTATE = 0,
        <remark>/// emissions output</remark>
        OS_EMISSIONS,
        <remark>/// trip information output</remark>
        OS_TRIPDURATIONS,
        <remark>/// route information output</remark>
        OS_VEHROUTE,
        <remark>/// TrafficOnline-SS2 output  // &lt;-- new entry</remark>
        OS_DEVICE_TO_SS2,             <remark>// &lt;-- new entry</remark>
        <remark>/// maximum value</remark>
        OS_MAX
    };
...</programlisting>

      <para>At first, we have to add the command-line option which will force
      the simulation to generate our new output by adding the following line
      to the method "<methodname>void SUMOFrame::fillOptions(OptionsCont
      &amp;oc)</methodname>":</para>

      <programlisting>    oc.doRegister("ss2-output", new Option_FileName());</programlisting>

      <para>This means that the user can enable the output using the option
      <option>--ss2-output=<replaceable>&lt;FILENAME&gt;</replaceable></option>.
      The application can determine whether this option is set using
      <code>oc.isSet("ss2-output")</code> and can retrieve the file name - if
      the option is set - using
      <code>oc.getString("ss2-output")</code>.</para>

      <para>Then we have to add procedures which build and close this new
      output. Most of the simulation wide output files are opened within
      "<methodname>std::vector&lt;OutputDevice*&gt;
      SUMOFrame::buildStreams(const OptionsCont &amp;oc)</methodname>". We add
      the following line to this method:</para>

      <programlisting>   ret[MSNet::OS_DEVICE_TO_SS2] = buildStream(oc, "ss2-output");</programlisting>

      <para><methodname>OutputDevice *SUMOFrame::buildStream(const OptionsCont
      &amp;oc, const std::string &amp;optionName)</methodname> will build our
      output device as soon as the user wants the output to be generated. If
      the option, <option>--ss2-output</option> in this case, is not given,
      buildStream returns 0 (the output stream is not build). The returned
      pointer to the stream - independent whether a stream was built or not -
      will be set into the returned list of output streams to use,
      "<varname>ret</varname>". This list is given to
      <classname>MSNet</classname> later and all opened streams will be closed
      and deleted as soon as the simulation ends.</para>
    </sect1>

    <sect1 id="howto_global_output-implementation-output_usage">
      <title>Using the Stream within the Simulation</title>

      <sect2 id="howto_global_output-implementation-output_usage-optional">
        <title>Making the Output optional</title>

        <para>In order not to create all outputs at every simulation run, but
        only those wished by the user, the list of currently wished outputs is
        managed by the <classname>MSCORN</classname>-class; CORN is an acronym
        for - COmpute Or Not. To add a new, optional output, we at first add
        the MSCORN-internal handle to the list of
        <classname>MSCORN</classname>-functions. Looking into
        <filename>MSCORN.h</filename>, you will find the following
        enumeration:</para>

        <programlisting>class MSCORN {
public:
<remark>    /**
     * @enum Function
     * A list of functions
     */
</remark>    enum Function {
        CORN_OUT_TRIPDURATIONS,
        CORN_OUT_EMISSIONS,
        CORN_OUT_VEHROUTES,

        CORN_VEH_REALDEPART,
        CORN_MEAN_VEH_TRAVELTIME,
        ...</programlisting>

        <para>You may notice, that the names of these first entries correspond
        with the simulation-wide outputs, "tripinfo-output",
        "emissions-output", and "vehroute-output", too. We add our new handle
        to the list changing this part of <classname>MSCORN</classname> like
        following, first:</para>

        <programlisting>class MSCORN {
public:
<remark>    /**
     * @enum Function
     * A list of functions
     */
</remark>    enum Function {
        CORN_OUT_TRIPDURATIONS,
        CORN_OUT_EMISSIONS,
        CORN_OUT_VEHROUTES,
        CORN_OUT_DEVICE_TO_SS2, <remark>// &lt;-- new handle</remark>

        CORN_VEH_REALDEPART,
        CORN_MEAN_VEH_TRAVELTIME,
        ...</programlisting>

        <para>We inform <classname>MSCORN</classname> that our new output is
        wished as soon as the simulation is initialised. This is done by
        extending the method "<methodname>void
        MSNet::initialiseSimulation()</methodname>" by the following
        lines:</para>

        <programlisting>    <remark>// ... the same for TrafficOnline-SS2 information</remark>
    if ( myOutputStreams[OS_DEVICE_TO_SS2]!=0 ) {
        MSCORN::setWished(MSCORN::CORN_OUT_DEVICE_TO_SS2);
    }</programlisting>

        <para>That means that the output will only be set as being wished if
        it was previously created.</para>
      </sect2>

      <sect2 id="howto_global_output-implementation-output_usage-global_access">
        <title>Adding a global Access</title>

        <para>To ease accessing the output stream, we'll save a pointer to it
        within the <classname>MSCORN</classname>-class. To do this, we extend
        <classname>MSCORN</classname> by adding a static pointer to the stream
        and a method to assign it. The changes in
        <filename>MSCORN.h</filename> are:</para>

        <programlisting>...
public:
...
    static void setVehicleDeviceTOSS2Output(OutputDevice *s);
...
private:
    static OutputDevice *myVehicleDeviceTOSS2Output;
...</programlisting>

        <para>And in <filename>MSCORN.cpp</filename>:</para>

        <programlisting>...
OutputDevice *MSCORN::myVehicleDeviceTOSS2Output = 0;
...
void
MSCORN::setVehicleDeviceTOSS2Output(OutputDevice *s)
{
    myVehicleDeviceTOSS2Output = s;
}
...</programlisting>

        <para>Furthermore, we have to use our new assignment method. This is
        done in "<methodname>void
        MSNet::closeBuilding(...)</methodname>":</para>

        <programlisting>...
   MSCORN::setVehicleDeviceTOSS2Output(streams[OS_DEVICE_TO_SS2]);
...</programlisting>

        <note>
          <para>The usage of pointer to the stream within
          <classname>MSCORN</classname> is not the most pretty way to use the
          stream. One could also use it directly within
          <classname>MSNet</classname>.</para>
        </note>
      </sect2>

      <sect2 id="howto_global_output-implementation-output_usage-writing_functions">
        <title>Adding writing Functions</title>

        <para>Now we have static interfaces for the output stream we can use.
        As the format of the data to generate is well defined, we'll use
        interfaces which allow only to access the stream with the set of
        values that shall be written. In <classname>MSCORN</classname>, we add
        a function for writing our messages. In <filename>MSCORN.h</filename>,
        we add:</para>

        <programlisting>...
    static void saveTOSS2_CalledPositionData(SUMOTime time,
        int callID, const std::string &amp;pos, int quality);
...</programlisting>

        <para>And in <filename>MSCORN.cpp</filename>:</para>

        <programlisting>...
void
MSCORN::saveTOSS2_CalledPositionData(SUMOTime time, int callID,
                                     const std::string &amp;pos,
                                     int quality)
{
    if(myVehicleDeviceTOSS2Output!=0) {
        myVehicleDeviceTOSS2Output-&gt;getOStream()
            &lt;&lt; "01;" &lt;&lt; time &lt;&lt; ';' &lt;&lt; callID &lt;&lt; ';' &lt;&lt; pos
            &lt;&lt; ';' &lt;&lt; quality &lt;&lt; "\n";
    }
}
...</programlisting>

        <para>Please notice the usage of the
        <classname>OutputDevice</classname>
        (<methodname>getOStream()</methodname>).</para>

        <para>Now we can write data into the stream from our devices. Data
        shall be written as soon as a call begins. To do this, as soon as one
        of our cell phone devices switches to the state
        "<constant>STATE_CONNECTED</constant>", we'll jump into
        <methodname>void MSCORN::saveTOSS2_CalledPositionData(SUMOTime time,
        int callID, const std::string &amp;pos, int quality);</methodname>
        with our current values:</para>

        <programlisting>...
    <remark>// TOL_SPEC_SS2 (1.2)</remark>
    if( m_State==STATE_CONNECTED
        &amp;&amp;
        MSCORN::wished(MSCORN::CORN_OUT_DEVICE_TO_SS2)) {

        MSCORN::saveTOSS2_CalledPositionData(
            MSNet::getInstance()-&gt;getCurrentTimeStep(), gCallID,
            myVehicle.getLane().edge().getID(), 0);
    }
...</programlisting>

        <para>That's the position where we write our data into the stream for
        this example.</para>

        <para><emphasis>That's all folks!</emphasis></para>
      </sect2>
    </sect1>
  </chapter>
</book>