/***************************************************************************
                          MSVehicle.icc  -  Base for all
                          micro-simulation Vehicles. 
                             -------------------
    begin                : Mon, 05 Mar 2001
    copyright            : (C) 2001 by ZAIK http://www.zaik.uni-koeln.de/AFS
    author               : Christian Roessel
    email                : roessel@zpr.uni-koeln.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// $Log$
// Revision 1.1  2002/05/29 17:09:22  croessel
// Initial commit.
//

/**************** INCLUDE HEADER FILES HERE ********************************/


#include "MSLane.h"
#include "MSEdge.h"
#include "MSVehicleType.h"
#include "MSNet.h"
#include <iostream>
#include <cassert>
#include <cmath>
#include <cstdlib>
#include <algorithm>


/**************** DO NOT INCLUDE ANYTHING AFTER THIS POINT *****************/
#ifdef DISABLE_INLINE
#define inline
#endif

/**************** DEFINE INLINE FUNCTIONS HERE *****************************/

inline
double
MSVehicle::dawdle( double speed ) const
{
    // generate random number out of [0,1]
    double random = static_cast< double >( rand() ) /
        static_cast< double >( RAND_MAX );
                   
    // Dawdle. 
    // TODO:
    // We already have a safe speed, if we dawdle max, is it possible
    // to reduce the speed 2*decel?
    speed -= myType->dawdle() * myType->accel() * MSNet::deltaT() * random;
    
    return max( static_cast< double >( 0 ), speed );
}

/////////////////////////////////////////////////////////////////////////////

inline
double 
MSVehicle::tau()
{ 
    return myTau;
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::pos() const
{
    return myState.myPos;
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::length() const
{
    return myType->length();
}

/////////////////////////////////////////////////////////////////////////////

inline
bool
MSVehicle::overlap( const MSVehicle* veh1, const MSVehicle* veh2 )
{
    if ( veh1->myState.myPos < veh2->myState.myPos ) {
        
        return veh2->myState.myPos - veh2->myType->myLength < 
               veh1->myState.myPos;
    }
    return veh1->myState.myPos - veh1->myType->myLength < 
           veh2->myState.myPos;
}
 
/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::vsafe( double speed, 
                  double decel, 
                  double gap2pred, 
                  double predSpeed ) const 
{
    // Calculate the Stefan Krauss (SK) vsafe.

    assert( speed >= 0 );
    assert( gap2pred >= 0 );
    assert( predSpeed >= 0 );
    double vsafe = predSpeed + 
        ( ( gap2pred - predSpeed * myTau ) / 
          ( ( ( predSpeed + speed ) / ( 2 * decel ) ) + myTau ) );

// This assertion has not the intended meaning because of doubleing inaccuracy.
//    assert( vsafe <= gap2pred ); // Collision-free condition.
// This is not the solution, because vsafe allows this vehicle to overlap at 
// time t+1 with pred at time t.
//    assert( vsafe <= gap2pred + 0.01 ); 
    assert( vsafe >= 0 );

    return vsafe;
}

/////////////////////////////////////////////////////////////////////////////

inline
double 
MSVehicle::vMin( double v1, double v2, double v3, double v4 ) const
{
    return min( min( v1, v2 ), min ( v3, v4 ) );
}

/////////////////////////////////////////////////////////////////////////////

inline
bool 
MSVehicle::congested()
{
    return myState.mySpeed < 60.0 / 3.6;
}

/////////////////////////////////////////////////////////////////////////////


#ifdef DISABLE_INLINE
#undef inline
#endif

// Local Variables:
// mode:C++
// End:


