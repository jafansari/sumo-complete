<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
  <bookinfo>
    <title>SUMO developer documentation</title>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter>
    <title>The application sub-system</title>

    <para>Beside some tools, all of the applications within the SUMO-package
    share the same subsystem, only paramterised with two application-specific
    functions for setting and validating the command line options or the
    configuration settings. This subsystem initialises handles initialisation
    of the xml-subsystem, the options-subsystem and the message handling
    sub-system. All of these and the main application subsystem are described,
    herein.</para>

    <para>Read this if you want to extend an application&#39;s options.</para>

    <sect1>
      <title>The subsystems&#39; duties</title>

      <para>The subsystems were invented to avoid doing the same things for
      each of the package&#39;s application once again. All of them do parse
      command line options and optional a configuration file, they all have to
      initialise and close the XML-subsystem and all use the same paradigm of
      logging messages, either directly to the user via the command line
      output (cout) or by writing a log-file. By sharing the same methods, it
      is also assured, that all applications have the same behaviour.</para>

      <sect2>
        <title>The Main Subsystem</title>

        <para>This is a wrapper around the following three subsystems.</para>
      </sect2>

      <sect2>
        <title>The XML-Subsystem</title>

        <para>This simply initialises and closes the xerces-XML-parser (both
        being two method calls within a try/catch-block). We do not exactly
        know what xerces is doing here, but it does not work without.</para>
      </sect2>

      <sect2>
        <title>The Messaging-Subsystem</title>

        <para>From the version 0.8 on, SUMO is able to generate a log-file
        where all messages, warnings or errors are saved. The messaging
        subsystem is responsible to build the output files, to set the report
        options, such as whether the messages shall be verbose on the command
        line or within the logfile, the same for warnings etc. This is done
        the same way through all applications.</para>
      </sect2>

      <sect2>
        <title>The Options-Subsystem</title>

        <para>A SUMO-application&#39;s options may be set both on the command
        line and within a configuration file or both. The options-subsystem
        calls two methods which must be supplied on the main subsystem&#39;s
        initialisation. The first one fills the options-container with
        application-dependent options, the second method verifies them after
        they are set with the user&#39;s values.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>The subsystems&#39; usage</title>

      <para>If you look into the main procedures from the files
      &#34;*_main.cpp&#34; within the top-level source folder, you realise
      they all look similar:<programlisting>int
main(int argc, char **argv)
{
    int ret = 0;
    try {
        if(!SystemFrame::init(true, argc, argv,
            fillInitOptions, checkInitOptions, help)) {
            throw ProcessError();
        }

... do something application-specific ...

    } catch(ProcessError) {
        MsgHandler::getErrorInstance()-&#62;inform(&#34;Quitting (on error).&#34;);
        ret = 1;
    }
    SystemFrame::close();
    return ret;
}</programlisting></para>

      <para>The return value is initialised (using the static function<function>
      SystemFrame::init(bool, int, char**, FUNC_fill_options,
      FUNC_check_options, char**) </function>) first to &#34;no error&#34;
      (==0), then, within a try/catch-block the subsystem is initialised and
      the application-specific data processing method calls follow. The
      try/catch-block is needed as we allow each application to throw a
      &#34;ProcessError&#34; allowing easy aborting of the program&#39;s
      execution on any place the input is not proper.</para>

      <para>Either after completing the actions or If the
      subsystem-initialisation or the data processing fails, the subsystem is
      closed using <function>SystemFrame::close()</function> (which is a
      static function).</para>

      <para>These two calls wrap all the initialisations described above:
      XML-subsystem initialisation and closing, parsing of command line
      options and/or the configuration file, message subsystem initialisation.</para>

      <para>As you see, the pointers to two functions must be supplied:</para>

      <formalpara>
        <title>FUNC_fill_options</title>

        <para>Is the function which is called on initialisation of the
        command-line options storage. It is declared as following within
        <function>OptionsSubSys.h</function>:</para>
      </formalpara>

      <para><function>typedef void (fill_options)(OptionsCont &#38;);</function></para>

      <para>It receives a reference of options storage to fill. The next
      chapter describes how to insert possible command line options into it.</para>

      <formalpara>
        <title>FUNC_check_options</title>

        <para>Is the function which is called on initialisation of the
        command-line options storage. It is declared as following within
        <function>OptionsSubSys.h</function>:</para>
      </formalpara>

      <para><function>typedef bool (check_options)(OptionsCont &#38;);</function></para>

      <para>Using the methods to retrieve single options from the options
      storage described within the next chapter, one can check whether the
      user&#39;s definitions are proper. The method must return true if
      everything&#39;s ok with the user input, otherwise - when a necessary
      network file definition is not given, f.e. , false.</para>

      <sect2>
        <title>The Options Subsystem</title>

        <para>All major SUMO applications use the same classes for parsing of
        command line options and configuration files. Each application has
        exactly one instance of the <function>OptionsCont</function> (options
        container) - class. Before the command line options are parsed, their
        names, allowed types and their default values must be inserted into
        this container. This is done within a method given to the main
        subsystem as described above.</para>

        <para>To insert an application option into the container, use one of
        the following polymorphs:</para>

        <para><function>void doRegister(const std::string &#38;name1, Option
        *v);</function></para>

        <para>or</para>

        <para><function>void doRegister(const std::string &#38;name1, char
        abbr, Option *v);</function></para>

        <para>The parameter &#34;name1&#34; is the name (or one of the
        possible name, better to say) you&#39;ll be able to retrieve
        information about the command line option&#39;s state after parsing
        the command line arguments and/or the configuration file. The
        character &#34;abbr&#34; within the second call is the possible
        one-char abbreviation of the name. </para>

        <para><caution><para><inlinegraphic
        fileref="./gfx/attention_small.gif" format="GIF" /> The behaviour
        after adding the same abbreviation for two different options is not
        defined.</para></caution></para>

        <para>The third parameter is an option that shall be assigned to the
        name(s). Remark that the <function>OptionsCont</function> takes the
        responsibility for this option - it will be deleted when the
        <function>OptionsCont</function> is deleted. The option itself must be
        an instance of one of the following classes, which all are derived
        from the class <function>Option</function>:</para>

        <itemizedlist>
          <listitem>
            <para><function>Option_Integer</function> </para>
          </listitem>

          <listitem>
            <para><function>Option_Long</function></para>
          </listitem>

          <listitem>
            <para><function>Option_String</function></para>
          </listitem>

          <listitem>
            <para><function>Option_Float</function></para>
          </listitem>

          <listitem>
            <para><function>Option_FileName</function></para>
          </listitem>

          <listitem>
            <para><function>Option_UIntVector</function></para>
          </listitem>
        </itemizedlist>

        <para>The names of the classes reflect the types which are awaited for
        the option. Do also remark, that later acces for reading should be
        done in dependence to the type - it means that you should not try to
        get a float from an <function>Option_Float</function>. This yould
        yield in an exception.</para>

        <para><caution><para><inlinegraphic
        fileref="./gfx/attention_small.gif" format="GIF" /> All subclasses of
        are stored within the file . This is surely not as wished within the
        coding styleguide, each class should be stored in a separate pair of
        files. Also, one could imagine to use templates, here.</para></caution></para>

        <para>Also, every of the option subclasses has two constructors: one
        that is parametrised with the appropriate type and a parameterless
        one. The parametrised constructor is used to supply default values for
        options, in the other case, no value is known to the system at first.
        An example: settings the &#34;verbose&#34;-switch as following, lets
        the application run quiet as default:</para>

        <programlisting>oc.doRegister(&#34;verbose&#34;, &#39;v&#39;, new Option_Bool(false));</programlisting>

        <para>Examples of how to insert possible options into their container
        may be found within the files <filename>src\sumo_only\SUMOFrame.cpp</filename>,
        <filename>src\gui_main.cpp</filename>, <filename>src\router_main.cpp</filename>,
        <filename>src\od2trips_main.cpp</filename> and <filename>src\netbuild\NBOptionsIO.cpp</filename>.</para>

        <para>Beside this, one can also add synonymes for options. If you for
        example want to implement the option
        &#34;name-of-vehicle-that-shall-halt&#34;, but wish to have a shorter
        name, too, use the following to make the same option accessable using
        both &#34;name-of-vehicle-that-shall-halt&#34; and &#34;v2h&#34;:</para>

        <programlisting>oc.doRegister(&#34;name-of-vehicle-that-shall-halt&#34;, new Option_String());
oc.addSynonyme(&#34;name-of-vehicle-that-shall-halt&#34;, &#34;v2h&#34;);</programlisting>

        <para>If no default value was supplied for an option, you should ask
        the OptionsCont whether it has been set. Access to values of unset
        options causes exceptions. This may sound hard, but as it&#39;s only
        the developer who accesses the options container in fact, it&#39;s the
        best way to assure security of the code.</para>

        <para>One can check whether a value is available for a certain option
        calling the OptionsCont-member method bool
        isSet(&#34;OPTION_NAME&#34;);. If one has to know whether it is the
        default value given on instantiation of the option (see above) or a
        value supplied by the user, he/she may call &#34;bool
        isDefault(&#34;OPRION_NAME&#34;);&#34;, a member method of
        OptionsCont, too. In dependence to the type of an option, one can
        retrieve her value using the following methods from OptionsCont:</para>

        <itemizedlist>
          <listitem>
            <para><function>int getInt(&#34;&#60;OPTION_NAME&#62;&#34;) const;</function></para>
          </listitem>

          <listitem>
            <para><function>long getLong(&#34;&#60;OPTION_NAME&#62;&#34;)
            const;</function></para>
          </listitem>

          <listitem>
            <para><function>std::string
            getString(&#34;&#60;OPTION_NAME&#62;&#34;) const;</function></para>
          </listitem>

          <listitem>
            <para><function>float getFloat(&#34;&#60;OPTION_NAME&#62;&#34;)
            const;</function></para>
          </listitem>

          <listitem>
            <para><function>const UIntVector
            &#38;OptionsCont::getUIntVector(&#34;&#60;OPTION_NAME&#62;&#34;)
            const;</function></para>
          </listitem>
        </itemizedlist>

        <para>Using an inproper method yields in an exception.</para>

        <para>You may have noticed, that there is one method to retrieve a
        certain value less than types available. The type
        &#34;Option_FileName&#34; returns a string, too. The only difference
        is their type which allows a different processing of the values to set
        when parsing.</para>
      </sect2>

      <sect2>
        <title>The Messaging Subsystem</title>

        <para>.</para>
      </sect2>

      <sect2>
        <title>The XML Subsystem</title>

        <para>This subsystem is automatically processed by the main subsystem.
        There should be no need to change it.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Assigned Classes</title>

      <sect2>
        <title>The Main Subsystem</title>

        <para>Made of only one class, located in <filename>utils/common/SystemFrame.h</filename>
        and <filename>utils/common/SystemFrame.cpp</filename>.</para>
      </sect2>

      <sect2>
        <title>The Options Subsystem</title>

        <para>All classes needed to store and process options can be found
        within <filename>utils/options/</filename></para>
      </sect2>

      <sect2>
        <title>The Message Subsystem</title>

        <para>All classes needed to store and process options can be found
        within <filename>utils/common/</filename>. The files
        <filename>MsgHandler.h</filename> and <filename>MsgHandler.cpp</filename>
        include the definition of the messaging system itself, the class
        <filename>MsgRetriever.h</filename> holds the interface which has to
        be implemented by classes that wish to retrieve information from the
        messaging system. </para>
      </sect2>

      <sect2>
        <title>The XML Subsystem</title>

        <para>Made of only one class, located in <filename>utils/xml/XMLSubSys.h</filename>
        and <filename>utils/xml/XMLSubSys.cpp</filename>.</para>
      </sect2>
    </sect1>
  </chapter>
</book>
