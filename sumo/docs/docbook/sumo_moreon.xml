<?xml version="1.0" encoding="UTF-8"?>
<book
><bookinfo
><title
>SUMO - More on...</title
><author
><firstname
>Daniel</firstname
><surname
>Krajzewicz</surname
><affiliation
><address
><email
>Daniel.Krajzewicz@dlr.de</email
></address
></affiliation
></author
><author
><firstname
>Danilot</firstname
><surname
>Tete Boyom</surname
></author
><releaseinfo
>$Revision$</releaseinfo
></bookinfo
><toc
></toc
><chapter
id="more_intro"
><title
>Introduction</title
><sect1
><title
>What is SUMO?</title
><para
>SUMO is a traffic simulation tool. It was primarily designed for urban street networks, but it may also be used for highway traffic simulations. In the near future it will be extended to model other transit modes simultaneously with ordinary car traffic.</para
><para
>You can obtain more information at <ulink
url="http://sumo.sourceforge.net"
>http://sumo.sourceforge.net/</ulink
>.</para
></sect1
><sect1
><title
>About this document</title
><para
>This document describes some certain parts SUMo covers in a larger detail than the developer documentation or the user documentation do.</para
><para
>This document is still under development and is meant to grow with the software. Due to this, you may find it together with the sources within out repository at sourceforge (<ulink
url="http://sumo.sourceforge.net"
>http://sumo.sourceforge.net/</ulink
>). It should always describe the current version.</para
></sect1
><sect1
><title
>Call for Help</title
><para
>Please let us know when either the document remains at any point unclear or any of the applications does not behave as expected. We also seek for some participants and further users, not only to share the development tasks, but also to gain some feedback and critics or some usage examples.</para
><para
>Every help is appreciated. Thank you.</para
></sect1
></chapter
><chapter
id="more_tls"
><title
>More on... Traffic Lights</title
><para
>Within this first chapter, we will describe how traffic lights are implemented and used within SUMO. As basically, traffic lights affect the right-of-way rules at a junction, we will first describe how right-of-way rules are implemented within SUMO. Afterwards, the additional concept of traffic lights is given.</para
><para
><emphasis
>Audience:</emphasis
> developers of traffic light system logics</para
><sect1
><title
>Right-Of-Way Rules in SUMO</title
><sect2
><title
>Links: A Connection between Lanes</title
><para
>Each lane (<classname
>MSLane</classname
>) beside dead ends has a list of at least one following lane. A link (MSLink) connects this following and the lane we regard. Basically, we consider two types of connections between lanes. In the first case, vehicles are able to pass the connection every time, without regarding other, possibly crossing traffic. Such connections may be found at highways or if the connection is a primary road and it is assured that the vehicle is able to pass this link without a collision. Such connections are called &#34;<emphasis
>priorised</emphasis
>&#34; connections. The other connections are called &#34;<emphasis
>unpriorised</emphasis
>&#34;. They are found on minor roads and a vehicle passing them must decelerate in front of them, because it may have to stop to let other vehicles pass the junction first. Please regard, that a junction may consist of several connections (links) of different type.</para
></sect2
><sect2
><title
>Usage of Links within the Simulation</title
><para
>If a vehicle approaches a link (<classname
>MSLink</classname
>), it lets the link know about it by calling <function
>void <classname
>MSLink</classname
>::setApproaching(<classname
>MSVehicle</classname
> *approaching)</function
>. This is done in <function
>void <classname
>MSVehicle</classname
>::vsafeCriticalCont( SUMOReal boundVSafe )</function
> as soon as a vehicle will have to decelerate to manage to stop in front of the link. Even if the vehicle is too near or too fast to decelerate in front of the link, the link will still be informed until the vehicle will finally pass it. By doing this, each link knows whether a vehicle is approaching or not and stores this vehicle in <varname
>MSLink::myApproaching</varname
>. In addition, the information about approaching a link is stored by the link into the <classname
>MSLogicJunction::Request </classname
>structure of the junction (<classname
>MSRightOfWayJunction</classname
>) it belongs to. After all vehicles have stored this information, <classname
>MSRightOfWayJunction</classname
> is able to compute which of the approaching vehicles will have to wait and which not using its <classname
>MSJunctionLogic</classname
>.</para
><para
>If you are confused about all these classes, the next diagram which shows how the hierarchy of SUMO junction classes, may help you.</para
><note
><para
>Remark that some of the classes are interfaces with only one implementation. It is possible, that this tree is a matter to change in the next time.</para
></note
><figure
><title
>Junction classes within SUMO</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/CD_Junctions.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>In the next pass (but within the same simulation step), each of the vehicles is touched again, but by now it is known whether the vehicle is allowed to pass the junction using his link or not. If not, the vehicle will decelerate and stop in front of the link (or a vehicle in front of it, that is also waiting). If the link is &#34;unpriorised&#34;, the vehicle will decelerate in front of it, even if it may pass it. If the link is &#34;priorised&#34; and the vehicle may pass, the vehicle will continue his drive without being hindered.</para
></sect2
><sect2
><title
>Setting Information by MSLogicJunctions</title
><para
>As we have seen, a MSLogicJunction gives way to the vehicles after the knowledge about all incoming vehicles has been set. We have seen that this information was stored in a structure named &#34;<classname
>MSLogicJunction::Reques</classname
>t&#34;. This is simply a list of bits, a <classname
>std::bitset&#60;64&#62;</classname
>, where each bit represents the information whether a certain link is approached by a vehicle currently (it&#39;s then set to true otherwise it&#39;s false).</para
><para
>What traffic lights do is simply to mask off those requests which are approaching a currently red sign. By doing this, the response for these streams is also set to false which forces the approaching vehicles to stop in front of the junction. Furthermore, this method keeps the row-logic of the junction untouched, what allows to use it for letting vehicles moving left - in the part of the world that drives on the right sied, that means those streams which have to cross an enemy stream - wait until there is a gap in the enemy stream they can use to move over the junction.</para
><figure
><title
>TLS classes within SUMO</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/CD_TrafficLights.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
></sect2
><sect2
><title
>Switching the Phases</title
><para
>What we furthermore need to know is how a traffic light is forces to switch its phases and how the links get informed about this. When being instantiated, the tls adds an event to SUMO&#39;s event handler (<classname
>MSEventHandler</classname
>). This is done within the <classname
>MSTrafficLightLogic</classname
>-constructor, a class from which all tls algorithms are derived (see above). This event, being a <classname
>MSTrafficLightLogic::SwitchCommand</classname
> executes the following steps:</para
><programlisting
>SUMOTime execute() {
   size_t step1 = myTLLogic-&#62;getStepNo(); // get the current phase index
   SUMOTime next = myTLLogic-&#62;trySwitch(); // try to switch, get next duration
   size_t step2 = myTLLogic-&#62;getStepNo(); // get the phase index after possible switch
   if(step1!=step2) { // has the phase changed?
      myTLLogic-&#62;onSwitch(); // yes -&#62; do some further actions (see below)
      myTLLogic-&#62;setLinkPriorities(); // inform the links about current state
   }
   return next; // return period after which the tls shall be tried to switch again
}
</programlisting
><para
>Let&#39;s review it. At first, we remember the state of the tls before trying to switch it in the variable <varname
>step1</varname
>. This &#34;state&#34; is simply the index of the current tls phase. Then, we try to switch the tls using <function
>trySwitch()</function
> and gain the period to the next try which we save in <varname
>next</varname
>. After this, we check whether the tls has really changed by asking for its current step. If the step before and the step after trying to switch the tls are not the same, the tls has switched. We then inform the links about it using the <classname
>MSTrafficLightLogic::setLinkPriorities</classname
> function. The call to <function
>onSwitch</function
> should not bother you, herein. It is not a part of the tls-steering, but used to inform connected structures about the phase change. By now, only assigned detectors (see [!!!]) may be informed and their assignment is done separately from the tls-implementations. The comparison between the step before and after trying to switch is needed, as maybe the tls decides not to switch, yet, although the phases duration is over (see the <ulink
url="#more_tls-existing-static"
>description of the agentbased tls</ulink
>). After all has been done, we return the period to wait until we again try to switch the tls. If you want, your implementation of &#34;<function
>trySwitch</function
>&#34; may always return 1 in order to check the tls each simulation step.</para
></sect2
><sect2
><title
>The whole procedure</title
><para
>So the whole procedure of bringing a vehicle save over a junctions is as following:</para
><procedure
><step
><para
><function
>MSNet::myJunctions-&#62;resetRequests();</function
></para
><para
>This resets all junctions&#39; requests to false, that means, that no vehicles from previous steps may inference with the current network state</para
></step
><step
><para
>... (several other things may happen, here)</para
></step
><step
><para
><function
>MSNet::myEdges-&#62;moveCritical();</function
></para
><para
>Herein, vehicles which approach a junction set their request</para
></step
><step
><para
><function
>MSNet::myLogics-&#62;maskRedLinks();</function
></para
><para
>Requests for vehicles which have red are reset to false</para
></step
><step
><para
><function
>MSNet::myJunctions-&#62;setAllowed();</function
></para
><para
>The junctions compute which vehicles may pass them and which have to wait</para
></step
><step
><para
><function
>MSNet::myLogics-&#62;maskYellowLinks();</function
></para
><para
>Reallow vehicles trying to pass a yellow tls to pass the junction</para
></step
><step
><para
><function
>MSNet::myEdges-&#62;moveFirst();</function
></para
><para
>Move all those vehicles (not only the first one, but all first ones) that approach a junction</para
></step
></procedure
><para
>What is the meaning of the sixth step? Imagine what shall happen with vehicles driving over yellow. They should stop, but if they are too near to the junction, one has to let them through. Also, they have to be taken into account if an enemy stream exists. In this case, they maybe have to make vehicles on this stream wait. To achieve this, at first only red links are set to false. This is given as input to the junction&#39;s row-logics and that lets all vehicles having red wait, vehicles which have yellow may be able to pass the junction. Then, vehicles having yellow are set to false which lets them try to stop in front of the tls.</para
></sect2
></sect1
><sect1
><title
>Loading of TLS- and ROW-logics</title
><para
>Within the next subchapters, we will describe what all these information means and how it is parsed.</para
><sect2
><title
>XML-Representation</title
><sect3
><title
>Description of TLS-Logics</title
><para
>Normally, the descriptions of traffic lights are stored within the network descriptions and look like this (example from <filename
>cross3ltl.net.xml</filename
>):</para
><para
><programlisting
format="linespecific"
linenumbering="unnumbered"
>&#60;tl-logic type=&#34;static&#34;&#62;
   &#60;key&#62;0&#60;/key&#62;
   &#60;logicno&#62;0&#60;/logicno&#62;
   &#60;phaseno&#62;8&#60;/phaseno&#62;
   &#60;offset&#62;0&#60;/offset&#62;
   &#60;inclanes&#62;1si_0 1si_1 1si_2 2si_0 2si_1 2si_2 3si_0 3si_1 3si_2 4si_0 4si_1 4si_2&#60;/inclanes&#62;
   &#60;phase duration=&#34;20&#34; phase=&#34;0000111100001111&#34; brake=&#34;1111110011111100&#34; yellow=&#34;0000000000000000&#34;/&#62;
   &#60;phase duration=&#34;4&#34; phase=&#34;0000110000001100&#34; brake=&#34;1111111111111111&#34; yellow=&#34;0000001100000011&#34;/&#62;
   &#60;phase duration=&#34;3&#34; phase=&#34;0000110000001100&#34; brake=&#34;1111001111110011&#34; yellow=&#34;0000000000000000&#34;/&#62;
   &#60;phase duration=&#34;4&#34; phase=&#34;0000000000000000&#34; brake=&#34;1111111111111111&#34; yellow=&#34;0000110000001100&#34;/&#62;
   &#60;phase duration=&#34;20&#34; phase=&#34;1111000011110000&#34; brake=&#34;1100111111001111&#34; yellow=&#34;0000000000000000&#34;/&#62;
   &#60;phase duration=&#34;4&#34; phase=&#34;1100000011000000&#34; brake=&#34;1111111111111111&#34; yellow=&#34;0011000000110000&#34;/&#62;
   &#60;phase duration=&#34;3&#34; phase=&#34;1100000011000000&#34; brake=&#34;0011111100111111&#34; yellow=&#34;0000000000000000&#34;/&#62;
   &#60;phase duration=&#34;4&#34; phase=&#34;0000000000000000&#34; brake=&#34;1111111111111111&#34; yellow=&#34;1100000011000000&#34;/&#62;
&#60;/tl-logic&#62;</programlisting
></para
><para
>This description is build during network conversion/generation within the netbuilding classes.</para
><para
>The meaning of the tags and the information stored within them is the following:</para
><itemizedlist
><listitem
><para
><sgmltag
>tl-logic</sgmltag
>: defines the begin of the description of a tls-logic</para
><para
>Attributes: <sgmltag
>type=&#34;static|actuated|agentbased&#34;</sgmltag
>; describes which tls-algorithm shall be used by this tls (string-enum)</para
><para
>Information in CDATA: none</para
></listitem
><listitem
><para
><sgmltag
>key</sgmltag
>: defines the begin of the description of a tls-logic</para
><para
>Attributes: none</para
><para
>Information in CDATA: the key (name) of the tls (string)</para
></listitem
><listitem
><para
><sgmltag
>logicno</sgmltag
>: unused by now, only tls-logics with logicno=0 are generated (since version 0.8.3) and read</para
><para
>Attributes: none</para
><para
>Information in CDATA: the number of the logic (int)</para
></listitem
><listitem
><para
><sgmltag
>phaseno</sgmltag
>: the number of phases this tls-logic has</para
><para
>Attributes: none</para
><para
>Information in CDATA: the number of phases of the logic (int)</para
></listitem
><listitem
><para
><sgmltag
>offset</sgmltag
>: the offset by which the tls shall change to next phase</para
><para
>This allows you to &#34;rotate&#34; the red/green phases. The offset is a delay to the simulation begin given in seconds with which the tls shall change to the next phase for the first time.</para
><para
>Attributes: none</para
><para
>Information in CDATA: the offset in seconds (int)</para
></listitem
><listitem
><para
><sgmltag
>inclanes</sgmltag
>: list of incoming lanes</para
><para
>Attributes: none</para
><para
>Information in CDATA: names (ids) of the lanes incoming to the tls</para
><caution
><para
>As far as I know, this information is rather buggy and unused. Should be rechecked.</para
></caution
></listitem
><listitem
><para
><sgmltag
>phase</sgmltag
>: definition of a phase (see below)</para
></listitem
></itemizedlist
><para
>The definitions of a phase should be investigated more deeply. Each phase has an own definition and the number of such definitions should be equal to the value stored in <sgmltag
>phaseno</sgmltag
>. The mandatory attributes store the following information:</para
><itemizedlist
><listitem
><para
><sgmltag
>duration</sgmltag
>: the duration of the phase in seconds</para
></listitem
><listitem
><para
><sgmltag
>phase</sgmltag
>: a bitset which holds the information which streams have a &#34;green&#34; light (1). Vehicles within these streams are allowed to pass the junctions, vehicles within streams that have a zero (0) here, have either &#34;red&#34; light in front or a &#34;yellow&#34; one</para
></listitem
><listitem
><para
><sgmltag
>brake</sgmltag
>: a bitset which holds the information which streams have to decelerate in front of the junction. Vehicles within a stream may have to decelerate either because they have a red or yellow light or because a foe stream has green, to (this is mostly the case for left-turning streams). Streams that have to decelerate are marked with a 1, here, zero (0) means the vehicles may pass without decelerating in front of the tls</para
></listitem
><listitem
><para
><sgmltag
>yellow</sgmltag
>: a bitset which holds the information which vehicles are in front of yellow lights (1).</para
></listitem
></itemizedlist
><caution
><para
>The indices of &#34;<sgmltag
>phase</sgmltag
>&#34;, &#34;<sgmltag
>brake</sgmltag
>&#34; and &#34;<sgmltag
>yellow</sgmltag
>&#34; are from right to left, that means the rightmost (last) entry will be later found at index 0.</para
></caution
><para
>Also some further non-mandatory attributes may be stored within the <sgmltag
>phase</sgmltag
>-tag. until now, these tags are used by the actuated and the agentbased tls only. They are:</para
><itemizedlist
><listitem
><para
><sgmltag
>min_duration</sgmltag
>: a minimum duration for the phase. The tls-logic may not shorten the duration of the phase below this value (int, in seconds)</para
></listitem
><listitem
><para
><sgmltag
>max_duration</sgmltag
>: a maximum duration for the phase. The tls-logic may not extend the duration of the phase beyond this value (int, in seconds)</para
></listitem
></itemizedlist
><para
>There is no possibility to insert values for <sgmltag
>min_duration</sgmltag
> and <sgmltag
>max_duration</sgmltag
> into the network descriptions by now but by hand.</para
></sect3
><sect3
><title
>Connections between streams and tls-logics</title
><para
>You probably have seen, that the <sgmltag
>inclanes-tag</sgmltag
> is buggy. In fact, the links (connections between two consecutive lanes, see above) are added almost at the end of the loading process. When a link is built, the tls-logic which controls it is informed about it getting the information which stream information is used by the link. This information is given as an index to the fields <sgmltag
>phase</sgmltag
>, <sgmltag
>brake</sgmltag
> and <sgmltag
>yellow</sgmltag
> from the <sgmltag
>phase</sgmltag
>-element of the tls-description described above.</para
><para
>The information about a link is represented as following (example from <filename
>cross3ltl.net.xml</filename
>):</para
><programlisting
><sgmltag
>&#60;succ edge=&#34;1si&#34; lane=&#34;1si_0&#34; junction=&#34;0&#34;&#62;
   &#60;succlane lane=&#34;3o_0&#34; via=&#34;:0_12_0&#34; tl=&#34;0&#34; linkno=&#34;12&#34; yield=&#34;1&#34; dir=&#34;r&#34; state=&#34;t&#34;/&#62;
&#60;/succ&#62; </sgmltag
></programlisting
><para
>Let&#39;s consider the element &#34;succlane&#34; only, the element &#34;succ&#34; gives us only the names of the edge/lane that is currently processed and the junction this edge/lane yields in.</para
><itemizedlist
><listitem
><para
><sgmltag
>lane</sgmltag
>: the connected lane&#39;s id (mandatory, string)</para
></listitem
><listitem
><para
><sgmltag
>via</sgmltag
>: the connected internal lane&#39;s id (mandatory, string)</para
><caution
><para
>internal lanes are not yet supported, this is just a developer&#39;s information by now</para
></caution
></listitem
><listitem
><para
><sgmltag
>tl</sgmltag
>: the id of the tls-logic that is responsible for this link; this field is missing if the link is not controlled by a tls</para
></listitem
><listitem
><para
><sgmltag
>linkno</sgmltag
>: the index of the information within the controlling tls logic that shall be used for this link</para
></listitem
><listitem
><para
><sgmltag
>yield</sgmltag
>: information whether vehicles have to wait in front of this link (valid only for uncontrolled links)</para
></listitem
><listitem
><para
><sgmltag
>dir</sgmltag
>: the information about which arrow shall be drawn for this link</para
></listitem
><listitem
><para
><sgmltag
>state</sgmltag
>: the information what kind of state shall be drawn</para
></listitem
></itemizedlist
></sect3
></sect2
><sect2
><title
>Parsing the network description</title
><para
>As described in <ulink
url="http://sumo.sourceforge.net/docs/gen/dev_chp03.shtml#dev_chp03-loading"
>Developer Docs - Chapter 3. SUMO - 3.2. Loading</ulink
>, an instance of NLHandler is used to parse the XML-descriptions of the network and of the tls-logics contained herein. All elements related to traffic lights and junctions at all are delegated to an instance of NLJunctionControlBuilder (from version 0.9.0 on). Herein, the whole description is stored temporarily until the complete description has been read. Then, as the closing <sgmltag
>tl-logic</sgmltag
> tag occures, the tls logic is build in accordace to the read type.</para
></sect2
></sect1
><sect1
><title
>How to implement a new Traffic Lights Logic</title
><sect2
><title
>Existing APIs</title
><para
>...tbd...</para
></sect2
></sect1
><sect1
><title
>Existing LSA-Algorithms in SUMO</title
><sect2
id="more_tls-existing-static"
><title
>Static TLS (MSSimpleTrafficLightLogic)</title
><para
>This tls-type simply obtains the list of phases from the description and switches between the cycles after each cycle&#39;s period is over. We have seen that the tls algorithm is stored in <function
>trySwitch()</function
>. What a simple traffic light&#39;s implementation does is the following:</para
><programlisting
>SUMOTime
MSSimpleTrafficLightLogic::trySwitch()
{
    // increment the index
    myStep++;
    // if the last phase was reached ...
    if(myStep==myPhases.size()) {
        // ... set the index to the first phase
        myStep = 0;
    }
    // return offset to the next switch
    assert(myPhases.size()&#62;myStep);
    return myPhases[myStep]-&#62;duration;
}
</programlisting
><para
>That means that we simply rotate our index over the phases and return each phase&#39;s duration as the time that has to pass before the traffic light is switched one step further.</para
></sect2
><sect2
><title
>Actuated TLS</title
><para
>Sorry, we have found some inconvenient things within our implementation of Actuated TLS. We have to fix this, before we will describe the algorithm (dkrajzew, 14.11.2005). ... tbd ...</para
></sect2
><sect2
id="more_tls-existing-agentbased"
><title
>Agentbased TLS</title
><para
>...tbd...</para
></sect2
></sect1
></chapter
><chapter
id="more_emissions"
><title
>More on... Vehicle Handling</title
><para
>Being a traffic simulation, SUMO has to handle vehicles in many ways. This chapter describes how vehicles are used within the simulation, how they can be added to the net and several other aspects of vehicles within the simulation. This chapter is meant to be an add-on to the <ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp06.shtml"
>user documentation</ulink
>.</para
><para
><emphasis
>Audience:</emphasis
> users</para
><sect1
><title
>Vehicles in the microsim</title
><sect2
><title
>Used Structures</title
><para
>... tbd ...</para
><sect3
><title
>Route Definitions (MSRoute)</title
><para
>You</para
></sect3
><sect3
><title
>Vehicle Types (MSVehicleType)</title
><para
>You</para
></sect3
><sect3
><title
>Vehicles (MSVehicle)</title
><para
>You</para
></sect3
></sect2
><sect2
><title
>A Vehicle&#39;s Lifecycle</title
><para
>... tbd ...</para
></sect2
><sect2
><title
>The &#34;three edges rule&#34;</title
><para
>... tbd ...</para
></sect2
></sect1
><sect1
><title
>Emissions</title
><para
>In the real life, vehicles are parked somewhere in the near of the road and start their route from this place. A plain modelling of this is not useful because</para
><itemizedlist
><listitem
><para
>You would have to handle all vehicles, also those standing around what would cost you much memory and cpu time and would need more effort in modelling,</para
></listitem
><listitem
><para
>A simulation mostly takes place at a subpart of a network and vehicles come mostly from the boundaries of the simulated area.</para
></listitem
></itemizedlist
><para
>Due to this, within traffic simulations, vehicles are inserted into the net on emission and are deleted when leaving the simulation, either by leaving the area or by parking. This paradigm is also used within SUMO.</para
><sect2
><title
>Plain Emissions</title
><sect3
><title
>Emissions from normal Edges</title
><para
>The most common procedure to emit vehicles in SUMO is to insert them at normal edges (streets). This</para
></sect3
><sect3
><title
>Emissions from Source Edges</title
><para
>... tbd ...</para
></sect3
><sect3
><title
>Additional Parameter</title
><para
>... tbd ...</para
></sect3
></sect2
><sect2
><title
>Using TriggeredEmitters</title
><para
>... tbd ...</para
></sect2
></sect1
><sect1
><title
>Teleporting</title
><sect2
><title
>... tbd ...</title
><para
>...tbd...</para
></sect2
></sect1
></chapter
><chapter
id="more_trigger"
><title
>More on... Trigger</title
><para
>This chapter is meant to be an add-on to the <ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp06.shtml"
>user documentation</ulink
>.</para
><para
><emphasis
>Audience:</emphasis
> users</para
><sect1
><title
>Building an Own Trigger</title
><para
>To build an own trigger, use the following procedure:</para
><procedure
><step
><para
>Generate a class which is derived from <classname
>MSTrigger</classname
> (located in <filename
><replaceable
>&#60;SUMO&#62;</replaceable
>/src/microsim/trigger/</filename
>)</para
></step
><step
><para
>Add a reading procedure for this class within <classname
>NLTriggerBuilder</classname
></para
></step
><step
><para
>Generate the GUI-version of the trigger</para
></step
><step
><para
>Add the generation procedure in GUITriggerBuilder</para
></step
></procedure
><para
>We will now go through these steps using the MSBusStop-class as an example.</para
><sect2
><title
>Generate an own Class</title
><para
>Ok, this is not really that hard. A bus stop is simply a part of a lane, so we need the lane, the begin and the end position. Additionally we want to know which lines will hold there. Knowing this, we have to generate a MSBusStop.h and its implementation MSBusStop.cpp:</para
><programlisting
>#ifndef MSBusStop_h
#define MSBusStop_h

#include &#60;vector&#62;
#include &#60;string&#62;
#include &#34;MSTrigger.h&#34;

class MSLane;

class MSBusStop : public MSTrigger {
public:
    MSBusStop(const std::string &#38;id, const std::vector&#60;std::string&#62; &#38;lines,
        MSLane &#38;lane, SUMOReal begPos, SUMOReal endPos);
    virtual ~MSBusStop();

protected:
    std::vector&#60;std::string&#62; myLines;
    MSLane &#38;myLane;
    SUMOReal myBegPos;
    SUMOReal myEndPos;

};

#endif
</programlisting
><programlisting
>#include &#34;MSTrigger.h&#34;
#include &#34;MSBusStop.h&#34;


MSBusStop::MSBusStop(const std::string &#38;id,
                     const std::vector&#60;std::string&#62; &#38;lines,
                     MSLane &#38;lane,
                     SUMOReal begPos, SUMOReal endPos)
    : MSTrigger(id), myLines(lines), myLane(lane),
    myBegPos(begPos), myEndPos(myEndPos)
{
}

MSBusStop::~MSBusStop()
{
}
</programlisting
></sect2
><sect2
><title
>Add a reading Procedure</title
><para
>Take a look at MSTrigger *NLTriggerBuilder::buildTrigger(MSNet &#38;net, const Attributes &#38;attrs, const std::string &#38;base,const NLHandler &#38;helper). Think about a name for your trigger and add the call to a function which parses your structure. For our purpose, we will add the following lines to this function:</para
><programlisting
>    } else if(type==&#34;bus_stop&#34;) {
        t = parseAndBuildBusStop(net, attrs, base, helper);
    }
</programlisting
><para
>Then you of course have to implement the function that builds the structure itself. . To implement the function we add its declaration within NLTriggerBuilder&#39;s (NLTriggerBuilder.h) protected part:</para
><programlisting
>    /// builds a busstop
    MSBusStop *parseAndBuildBusStop(MSNet &#38;net,
        const Attributes &#38;attrs, const std::string &#38;base,
        const NLHandler &#38;helper);
</programlisting
><para
>... and it&#39;s definition in NLTriggerBuilder.cpp:</para
><programlisting
>MSBusStop *
NLTriggerBuilder::parseAndBuildBusStop(MSNet &#38;net,
                                       const Attributes &#38;attrs,
                                       const std::string &#38;base,
                                       const NLHandler &#38;helper)
{
    string id = helper.getString(attrs, SUMO_ATTR_ID);
    string objectid = helper.getString(attrs, SUMO_ATTR_OBJECTID);
    MSLane *lane = MSLane::dictionary(objectid);
    if(lane==0) {
        MsgHandler::getErrorInstance()-&#62;inform(
            string(&#34;The lane to use within MSEmitter &#39;&#34;)
            + id + string(&#34;&#39; is not known.&#34;));
        throw ProcessError();
    }
    SUMOReal frompos = helper.getFloat(attrs, SUMO_ATTR_FROM);
    SUMOReal topos = helper.getFloat(attrs, SUMO_ATTR_TO);
    if(frompos&#60;0) {
        frompos = lane-&#62;length() + frompos;
    }
    if(topos&#60;0) {
        topos = lane-&#62;length() + topos;
    }
    return buildBusStop(net, id, lane, frompos, topos, file);
}
</programlisting
><para
>Well, we have now parsed all the values we need from the XML-description which will have to look like this: <sgmltag
>&#60;trigger id=&#34;<replaceable
>&#60;ID&#62;</replaceable
>&#34; objecttype=&#34;bus_stop&#34; objectid=&#34;<replaceable
>&#60;LANE_ID&#62;</replaceable
>&#34; from=&#34;<replaceable
>&#60;FROM_POS&#62;</replaceable
>&#34; to=&#34;<replaceable
>&#60;TO_POS&#62;</replaceable
>&#34;/&#62;</sgmltag
>. We can now build the bus stop. We do this in a separate method, because it will be overwritten within the gui-version of NLTriggerBuild (see !!!). So we add the missing function (see below) to our declaration and definition of NLTriggerBuilder and we&#39;re finished (don&#39;t foret to add your trigger to the includes):</para
><para
>NLTriggerBuilder.h:</para
><programlisting
>    virtual MSBusStop* buildBusStop(MSNet &#38;net,
        const std::string &#38;id, MSLane *lane,
        SUMOReal frompos, SUMOReal topos);
</programlisting
><para
>NLTriggerBuilder.cpp:</para
><programlisting
>MSBusStop*
NLTriggerBuilder::buildBusStop(MSNet &#38;net, const std::string &#38;id,
                               MSLane *lane,
                               SUMOReal frompos, SUMOReal topos)
{
    return new MSBusStop(id, std::vector&#60;std::string&#62;(), lane, frompos, toPos);
}
</programlisting
></sect2
><sect2
><title
>Generate the GUI-version of the trigger</title
><para
>... tbd ...</para
></sect2
><sect2
><title
>Add a reading Procedure for the GUI</title
><para
>This is simple again. Simply extend the !!!</para
></sect2
></sect1
><sect1
><title
>Emissions</title
><para
>In the real life, vehicles are parked somewhere in the near of the road and start their route from this place. A plain modelling of this is not useful because</para
><itemizedlist
><listitem
><para
>You would have to handle all vehicles, also those standing around what would cost you much memory and cpu time and would need more effort in modelling,</para
></listitem
><listitem
><para
>A simulation mostly takes place at a subpart of a network and vehicles come mostly from the boundaries of the simulated area.</para
></listitem
></itemizedlist
><para
>Due to this, within traffic simulations, vehicles are inserted into the net on emission and are deleted when leaving the simulation, either by leaving the area or by parking. This paradigm is also used within SUMO.</para
><sect2
><title
>Plain Emissions</title
><sect3
><title
>Emissions from normal Edges</title
><para
>The most common procedure to emit vehicles in SUMO is to insert them at normal edges (streets). This</para
></sect3
><sect3
><title
>Emissions from Source Edges</title
><para
>... tbd ...</para
></sect3
><sect3
><title
>Additional Parameter</title
><para
>... tbd ...</para
></sect3
></sect2
><sect2
><title
>Using TriggeredEmitters</title
><para
>... tbd ...</para
></sect2
></sect1
><sect1
><title
>Teleporting</title
><sect2
><title
>... tbd ...</title
><para
>...tbd...</para
></sect2
></sect1
></chapter
><chapter
id="more_dua"
><title
>More on... Dynamic User Assignment</title
><para
>This chapter is meant to be an add-on to the <ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp06.shtml"
>user documentation</ulink
>. We will not discuss how to perform the DUA using SUMO, herein, this is described within chapter &#34;<ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp05.shtml#user_chp05-dua"
>Dynamic User Assignment</ulink
>&#34; of the <ulink
url="http://sumo.sourceforge.net/docs/userdocs.shtml"
>user documentation</ulink
>. What we would like to do instead is to talk some deeper aspects using a examples.</para
><para
><emphasis
>Audience:</emphasis
> users</para
><sect1
><title
>DUA on the City of Magdeburg from the INVENT Project</title
><sect2
><title
>Prerequisites</title
><para
>The next picture shows the network we have used within the project &#34;INVENT&#34;. It was given to us as an VISUM network. As VISUM-routes normally start at explicite feeding edges, we could reduce the network by removing geometry nodes. The routes were given as OD-matrices in a ptv-Format. They define the flows for the time betwee 5am and 12pm (!!!). After converting the matrices using <application
>OD2TRIPS</application
> into trips we were able to begin with the DUA. The assignment was made using the <filename
>iterate.pl</filename
> - script described here (tbd).</para
><figure
><title
>The network of City of Magdeburg used within INVENT as shown by SUMO</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/magdeburg_sumo.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
></sect2
><sect2
><title
>Evaluations of the DUA</title
><para
>The DUA has been run 40 times in order to check the behaviour of the algorithm. As output, we generated the vehicle emissions (see chapter tbd), vehicle trip duration (see chapter tbd) and edge-based dumps (see chapter TBD), the latest with aggregation times of 150s, 300s and 900s.</para
><para
>We will now examine the data generated, starting with the vehicle emissions file.</para
><sect3
><title
>Development of Vehicle Emissions</title
><para
>The vehicle emissions file (see chapter tbd) gives information about how many vehicles were loaded/runnning and have started/ended for each time stemp. Additionally, the time the simulation needed to compute the step is written.</para
><sect4
><title
>Running Vehicles</title
><para
>The next picture shows the development of the number of vehicles within the simulation over the dua iteration process. Every 5th iteration is shown. The plot was done using the following gnuplot command after converting the xml-output into files readable by gnuplot:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;veh&#34;
gnuplot&#62; plot &#34;emissions_0.txt&#34; u 1:4 w l, &#34;emissions_5.txt&#34; u 1:4 w l, \
   &#34;emissions_10.txt&#34; u 1:4 w l, &#34;emissions_15.txt&#34; u 1:4 w l, \
   &#34;emissions_20.txt&#34; u 1:4 w l, &#34;emissions_25.txt&#34; u 1:4 w l, \
   &#34;emissions_30.txt&#34; u 1:4 w l, &#34;emissions_35.txt&#34; u 1:4 w l</screen
><figure
><title
>Development of running vehicles over time and dua iteration step (iteration step number is increased by 5) (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/veh_time1.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>Lets review what we see:</para
><orderedlist
><listitem
><para
>The number of running vehicles decreases with each step</para
><para
>What we see here in fact is exactly the reason for using a dynamic user assignment. The large number of vehicles within the first iterations indicates that new vehicles are inserted into the network while the previously inserted have not yet left. The reason why previously inserted vehicles are still in the net is that they got stocked in jams. And the jams occured because all vehicles are trying to use the same route.</para
></listitem
><listitem
><para
>Not every following iteration step is better than the previous</para
><para
>It may be supposes that this may only be due to the dynamic changes within the simulation. That means, that both small changes within the routes&#39; distribution and the stochasticity in the microscopic model may yield in a larger jam which breaks down the network&#39;s capacity. Nevertheless, it is also possible that the microscopic model is not flexible enough not to cause the network to be free of jams and grid-locks as the reality is.</para
></listitem
></orderedlist
><para
>Now let&#39;s recheck the last steps (step 30-39) using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;veh&#34;
gnuplot&#62; plot &#34;emissions_30.txt&#34; u 1:4 w l, &#34;emissions_31.txt&#34; u 1:4 w l, \
   &#34;emissions_32.txt&#34; u 1:4 w l, &#34;emissions_33.txt&#34; u 1:4 w l, \
   &#34;emissions_34.txt&#34; u 1:4 w l, &#34;emissions_35.txt&#34; u 1:4 w l, \
   &#34;emissions_36.txt&#34; u 1:4 w l, &#34;emissions_37.txt&#34; u 1:4 w l, \
   &#34;emissions_38.txt&#34; u 1:4 w l, &#34;emissions_39.txt&#34; u 1:4 w l</screen
><figure
><title
>Development of running vehicles over time in steps 30-39 (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/veh_time2.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>If we remove those &#34;broken&#34; assignments, we can see that the development is almost closed at step 30 and only a small advantage can is done:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;veh&#34;
gnuplot&#62; plot &#34;emissions_30.txt&#34; u 1:4 w l, &#34;emissions_31.txt&#34; u 1:4 w l, \
   &#34;emissions_32.txt&#34; u 1:4 w l, &#34;emissions_33.txt&#34; u 1:4 w l, \
   &#34;emissions_36.txt&#34; u 1:4 w l, &#34;emissions_37.txt&#34; u 1:4 w l, \
   &#34;emissions_38.txt&#34; u 1:4 w l, &#34;emissions_39.txt&#34; u 1:4 w l</screen
><figure
><title
>Development of running vehicles over time in steps 30-39, step 34 and 35 excluded (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/veh_time3.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>It is not clear whether it is necessary to try the really optimal approach. One can assume that in reality, some drivers are still passing major roads they know without asking about a shorter possibility. As the next picture shows, the dua of step !!! is fitting very well to the data we got from detectors within Magdeburg.</para
><para
>One can state, that the dua is finished if the vehicles running in a simulation step is not changing over some iteration step dramatically. A real function or algorithm for evaluating this but is still missing.</para
></sect4
><sect4
><title
>Ended Vehicles</title
><para
>Almost the same information can be gained using the information about the number of vehicles that have left the simulation stored within the emissions file. As one may see within the next picture, the number of vehicles which have left the simulation is increasing with the iteration step. This of course has the same reasons as described within the previous chapter: the vehicles get stocked in the simulation due to jams.</para
><figure
><title
>Development of ended vehicles over time and dua iteration step (iteration step number is increased by 5) (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/ended_time1.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>This picture was done using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;ended&#34;
gnuplot&#62; plot &#34;emissions_0.txt&#34; u 1:6 w l, &#34;emissions_5.txt&#34; u 1:6 w l, \
   &#34;emissions_10.txt&#34; u 1:6 w l, &#34;emissions_15.txt&#34; u 1:6 w l, \
   &#34;emissions_20.txt&#34; u 1:6 w l, &#34;emissions_25.txt&#34; u 1:6 w l, \
   &#34;emissions_30.txt&#34; u 1:6 w l, &#34;emissions_35.txt&#34; u 1:6 w l</screen
></sect4
><sect4
><title
>Waiting Vehicles and the Mean Waiting Time</title
><para
>That vehicles are stocked may be also visualised using the number of waiting vehicles. Vehicles are declared as waiting if they can not be emitted into the network, because their departure edge is full. The next picture shows the development of this value during the simulations and the dua-steps.</para
><figure
><title
>Development of waiting vehicles over time and dua iteration step (iteration step number is increased by 5) (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/waiting_time1.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>This picture was done using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;waiting&#34;
gnuplot&#62; plot &#34;emissions_0.txt&#34; u 1:5 w l, &#34;emissions_5.txt&#34; u 1:5 w l, \
   &#34;emissions_10.txt&#34; u 1:5 w l, &#34;emissions_15.txt&#34; u 1:5 w l, \
   &#34;emissions_20.txt&#34; u 1:5 w l, &#34;emissions_25.txt&#34; u 1:5 w l, \
   &#34;emissions_30.txt&#34; u 1:5 w l, &#34;emissions_35.txt&#34; u 1:5 w l</screen
><para
>This is also visible when evaluating the mean waiting time:</para
><figure
><title
>Development of the mean waiting time over time and dua iteration step (iteration step number is increased by 5) (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/meanwaitingtime_time1.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>This picture was done using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;mean waiting time&#34;
gnuplot&#62; plot &#34;emissions_0.txt&#34; u 1:7 w l, &#34;emissions_5.txt&#34; u 1:7 w l, \
   &#34;emissions_10.txt&#34; u 1:7 w l, &#34;emissions_15.txt&#34; u 1:7 w l, \
   &#34;emissions_20.txt&#34; u 1:7 w l, &#34;emissions_25.txt&#34; u 1:7 w l, \
   &#34;emissions_30.txt&#34; u 1:7 w l, &#34;emissions_35.txt&#34; u 1:7 w l</screen
></sect4
><sect4
><title
>Mean Travel Time</title
><para
>The next picture shows how dramatically the dua changes the mean travel time.</para
><figure
><title
>Development of the mean travel time over time and dua iteration step (iteration step number is increased by 5) (tbd)</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/meantraveltime_time1.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>This picture was done using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;mean travel time&#34;
gnuplot&#62; plot &#34;emissions_0.txt&#34; u 1:8 w l, &#34;emissions_5.txt&#34; u 1:8 w l, \
   &#34;emissions_10.txt&#34; u 1:8 w l, &#34;emissions_15.txt&#34; u 1:8 w l, \
   &#34;emissions_20.txt&#34; u 1:8 w l, &#34;emissions_25.txt&#34; u 1:8 w l, \
   &#34;emissions_30.txt&#34; u 1:8 w l, &#34;emissions_35.txt&#34; u 1:8 w l</screen
><para
>... and for the last 10 steps:</para
><figure
><title
>Development of the mean travel time over time and dua iteration step for the last iteration steps</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/meantraveltime_time2.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>This picture was done using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;mean travel time&#34;
gnuplot&#62; plot &#34;emissions_30.txt&#34; u 1:8 w l, &#34;emissions_31.txt&#34; u 1:8 w l, \
   &#34;emissions_32.txt&#34; u 1:8 w l, &#34;emissions_33.txt&#34; u 1:8 w l, \
   &#34;emissions_34.txt&#34; u 1:8 w l, &#34;emissions_35.txt&#34; u 1:8 w l, \
   &#34;emissions_36.txt&#34; u 1:8 w l, &#34;emissions_37.txt&#34; u 1:8 w l, \
   &#34;emissions_38.txt&#34; u 1:8 w l, &#34;emissions_39.txt&#34; u 1:8 w l</screen
><para
>... and for those last steps where no vehicle blocked:</para
><figure
><title
>Development of the mean travel time over time and dua iteration step for the last and valid iteration steps</title
><mediaobject
><imageobject
><imagedata
align="center"
fileref="./gfx/more/meantraveltime_time3.gif"
format="GIF"
></imagedata
></imageobject
></mediaobject
></figure
><para
>using:</para
><screen
>gnuplot&#62; set xlabel &#34;t&#34;
gnuplot&#62; set ylabel &#34;mean travel time&#34;
gnuplot&#62; plot &#34;emissions_30.txt&#34; u 1:8 w l, &#34;emissions_31.txt&#34; u 1:8 w l, \
   &#34;emissions_32.txt&#34; u 1:8 w l, &#34;emissions_33.txt&#34; u 1:8 w l, \
   &#34;emissions_36.txt&#34; u 1:8 w l, &#34;emissions_37.txt&#34; u 1:8 w l, \
   &#34;emissions_38.txt&#34; u 1:8 w l, &#34;emissions_39.txt&#34; u 1:8 w l</screen
><para
>One may see that for the last steps of the last iterations, the mean travel time differs only by 30s. This is really not that important...</para
></sect4
></sect3
></sect2
></sect1
><sect1
><title
>Tools</title
><sect2
><title
>iterate.pl</title
><para
>tbd</para
></sect2
></sect1
></chapter
><chapter
id="more_performance"
><title
>More on... Simulation Performance</title
><para
>!!! This chapter is meant to be an add-on to the <ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp06.shtml"
>user documentation</ulink
>.</para
><para
><emphasis
>Audience:</emphasis
> users</para
><sect1
><title
>!!!</title
><sect2
><title
>!!!!</title
><para
>... tbd ...</para
><sect3
><title
>!!!</title
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
></sect2
><sect2
><title
>!!!!</title
><para
>... tbd ...</para
></sect2
><sect2
><title
>!!!</title
><para
>... tbd ...</para
></sect2
></sect1
><sect1
><title
>Further Ideas</title
><para
>There are of course some further possibilities to reduce the needed CPU time which are not yet implemented. There are two classes. The first one contains items which should not change the simulation&#39;s behaviour:</para
><itemizedlist
><listitem
><para
>no not recompute onAllowed each time the vehicle moves to a new lane, rather remove the first item only and keep track whether the next one should be recomputed using a seen distance value</para
></listitem
></itemizedlist
><para
>The first one contains items which may affect the simulation:</para
><itemizedlist
><listitem
><para
>do not move vehicles standing in jams (idea by Tomasz K. Jarzynka, tomee at kadu dot net)</para
></listitem
></itemizedlist
></sect1
></chapter
><chapter
id="more_model_extensions"
><title
>More on... Traffic Flow Model and Extensions</title
><para
>!!! This chapter is meant to be an add-on to the <ulink
url="http://sumo.sourceforge.net/docs/gen/user_chp06.shtml"
>user documentation</ulink
>.</para
><para
><emphasis
>Audience:</emphasis
> users</para
><sect1
><title
>!!!</title
><sect2
><title
>!!!!</title
><para
>... tbd ...</para
><sect3
><title
>!!!</title
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
></sect2
><sect2
><title
>!!!!</title
><para
>... tbd ...</para
></sect2
><sect2
><title
>!!!</title
><para
>... tbd ...</para
></sect2
></sect1
><sect1
><title
>Example Vehicle Parameter</title
><sect2
><title
>Busses</title
><para
>... tbd ...</para
><sect3
><title
>City Traffic Busses</title
><table
><title
>Parameters for City Traffic Busses</title
><tgroup
cols="6"
><thead
><row
><entry
>Type</entry
><entry
>Built</entry
><entry
>Capacity (sitting, standing, wheelchair)</entry
><entry
>Sizes (length, width, height)</entry
><entry
>max vel. (km/h)</entry
><entry
>Number</entry
></row
></thead
><tbody
><row
><entry
>MB O 405 N</entry
><entry
>1990-1995</entry
><entry
>31-38 / 59-69 / 1</entry
><entry
>11.6-11.8 / 2.5 / 2.9</entry
><entry
>80</entry
><entry
>Berlin: 154 (2005)</entry
></row
><row
><entry
>EvoBus Cito O 520</entry
><entry
>2001</entry
><entry
>14 / 34 / 1</entry
><entry
>8.9 / 2.4 / 2.9</entry
><entry
>75</entry
><entry
>Berlin: 7 (2005)</entry
></row
><row
><entry
>EvoBus Cito O 530 / 2002</entry
><entry
>2002</entry
><entry
>26 / 69 / 1</entry
><entry
>12. / 2.6 / 3.1</entry
><entry
>85</entry
><entry
>Berlin: 97 (2005)</entry
></row
><row
><entry
>EvoBus Cito O 530 / 2005</entry
><entry
>2005</entry
><entry
>29 / 68 / 1</entry
><entry
>12. / 2.6 / 3.1</entry
><entry
>80</entry
><entry
>Berlin: 30 (2005)</entry
></row
><row
><entry
>MAN NL 202</entry
><entry
>1990-1991</entry
><entry
>37 / 69 / 1</entry
><entry
>11.7-11.8 / 2.5 / 2.9</entry
><entry
>74</entry
><entry
>Berlin: 19 (2005)</entry
></row
><row
><entry
>MAN ND 202</entry
><entry
>1995</entry
><entry
>71 / 24 / 1</entry
><entry
>11.8 / 2.5 / 4.1</entry
><entry
>74</entry
><entry
>Berlin: 86 (?)</entry
></row
></tbody
></tgroup
></table
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
><sect3
><title
>!!!</title
><para
>You</para
></sect3
></sect2
><sect2
><title
>!!!!</title
><para
>... tbd ...</para
></sect2
><sect2
><title
>!!!</title
><para
>... tbd ...</para
></sect2
></sect1
></chapter
><chapter
id="more_tests"
><title
>More on... Software Tests</title
><para
>Since version 0.9.3 we support smoe basic tests which prove the software functionality. The number of the available tests is not that large, yet, but it will hopefuly grow with time. Ths chapter describes how to set up the testing system and how to use it.</para
><para
><emphasis
>Audience:</emphasis
> developers</para
><sect1
><title
>Acceptance Testing using TextTest</title
><sect2
><title
>About</title
><para
>We use &#34;<ulink
url="http://texttest.carmen.se/"
>TextTest</ulink
>&#34; to test whether the sosftware still behaves as expected. What this application does is simply to compare an application&#39;s output (both normal and errors) and optionally also the output generated by the application with predefined outputs from files.</para
><para
>There are some advantages and disadvantages of this approach. On the one hand, you can guarantee that the application is doing what is wanted by comparing all outputs with files you think are right. But this is also the problem with this approach: you do not have the assurance that the files you are comparing the current outputs to ARE right - you have to check these by hand.</para
><para
>Anyhow, I think that for the current progress stage, this approach should be used, because a) the tests are quite small and errors can be easily seen b) it is working.</para
></sect2
><sect2
><title
>Install</title
><para
>At first, you have to download and install &#34;<ulink
url="http://texttest.carmen.se/"
>TextTest</ulink
>&#34; from <ulink
url="http://texttest.carmen.se/"
>http://texttest.carmen.se/</ulink
>. The installation seems to be not that easy at first, but if you just follow the steps described in TestText&#39;s documentation, you&#39;ll have the system up and running in some minutes. Before continuing, please check whether the tests included with the TextTest distribution run before proceeding.</para
><para
>After installing TextTest, you have to set two environment variables in order to make the system run. They are:</para
><itemizedlist
><listitem
><para
><envar
>TEXTTEST_HOME</envar
></para
><para
>Set it to the path SUMO-tests are located in (<filename
>&#60;SUMO&#62;/tests</filename
> for the tests that come with the distribution)</para
></listitem
><listitem
><para
><envar
>SUMO_DIST</envar
></para
><para
>Set it to the path the SUMO distribution is located in (<filename
><replaceable
>&#60;SUMO_DIST&#62;</replaceable
></filename
>)</para
></listitem
></itemizedlist
><para
>The first environment variable forces TextTest to use the specified directory as source of tests. The second one is needed, because we have not seen a better possibility to specify which files should be used as input to the tests than using the files located in our examples-folder.</para
><para
>But, yep, this should be all on installing the tests-subsystem so far.</para
></sect2
><sect2
><title
>Running the Tests</title
><para
>Within the &#60;SUMO&#62;/tests - folder you can find batch-files which start TextTest. &#34;runAllTests.bat&#34; starts TextTest for testing all apllications located in the folder, &#34;<filename
>runNetconvertTests.bat</filename
>&#34; will only show tests for <application
>NETCONVERT</application
>, &#34;<filename
>runDuarouterTests.bat</filename
>&#34; only those for <application
>DUAROUTER</application
> etc,</para
></sect2
><sect2
><title
>Setting up new Tests</title
><para
>Please follow the instructions for TextTest. The system is configured in a way that output networks should have the name &#34;net.net.xml&#34; and should be wirtten to the current folder. If you add your tests this way, the messages the system prints (both normal and errors) and the generated files should be compared with the expected files.</para
></sect2
><sect2
><title
>Coverage and Results</title
><para
>As said before, the tests subsystem is quite new. Further tests have to be added. The following tests are currently available:</para
><table
><title
>Tests for DUAROUTER</title
><tgroup
cols="1"
><thead
><row
><entry
>Test Set Description</entry
></row
></thead
><tbody
><row
><entry
><emphasis
>Tests whether showing meta-information works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/meta/help</filename
></entry
><entry
>checks whether printing help works</entry
></row
><row
><entry
><filename
>duarouter/meta/version</filename
></entry
><entry
>checks whether printing version works</entry
></row
><row
><entry
><filename
>duarouter/trips/noop</filename
></entry
><entry
>checks what happens when no argument is given</entry
></row
></tbody
></entrytbl
></row
><row
><entry
><emphasis
></emphasis
></entry
></row
><row
><entry
><emphasis
>Checks whether the import of route alternatives works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/alternatives/increasing_time</filename
></entry
><entry
>plain old style alternatives with increasing departue time</entry
></row
><row
><entry
><filename
>duarouter/alternatives/newstyle_noid_increasing_time</filename
></entry
><entry
>new style alternatives with increasing departure times</entry
></row
><row
><entry
><filename
>duarouter/alternatives/newstyle_noid_one_time</filename
></entry
><entry
>new style alternatives with one departure time</entry
></row
><row
><entry
><filename
>duarouter/alternatives/newstyle_noid_unsorted_time</filename
></entry
><entry
>new style alternatives with random departure time with and <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/alternatives/one_time</filename
></entry
><entry
>plain old style alternatives with one departue time</entry
></row
><row
><entry
><filename
>duarouter/alternatives/unsorted_time</filename
></entry
><entry
>plain old style alternatives with random departure time and <option
>--unsorted</option
> set</entry
></row
></tbody
></entrytbl
></row
><row
><entry
><emphasis
></emphasis
></entry
></row
><row
><entry
><emphasis
>Checks whether the import of flows works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/flows/flows2routes</filename
></entry
><entry
>simple test with 100 vehicles and one departure time</entry
></row
><row
><entry
><filename
>duarouter/flows/flows2routes_100s_interval</filename
></entry
><entry
>simple test with 100 vehicles with departure interval between 0 and 100s</entry
></row
><row
><entry
><filename
>duarouter/flows/flows2routes_100s_interval_ext</filename
></entry
><entry
>The same as flows2routes_100s_interval but the interval is specified using an enclosing element</entry
></row
><row
><entry
><filename
>duarouter/flows/flows2routes_200s_interval</filename
></entry
><entry
>simple test with 100 vehicles with departure interval between 0 and 200s</entry
></row
><row
><entry
><filename
>duarouter/flows/flows2routes_200s_interval_ext</filename
></entry
><entry
>The same as flows2routes_200s_interval but the interval is specified using an enclosing element</entry
></row
><row
><entry
><filename
>duarouter/flows/flows2routes_100s_interval_withcolor</filename
></entry
><entry
>Checks whether defining colors works</entry
></row
></tbody
></entrytbl
></row
><row
><entry
><emphasis
></emphasis
></entry
></row
><row
><entry
><emphasis
>Checks whether the import of trips works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/trips/increasing_time</filename
></entry
><entry
>100 trips, departure time is increasing</entry
></row
><row
><entry
><filename
>duarouter/trips/increasing_time_notype</filename
></entry
><entry
>same as increasing_time, but no type is given in the trips</entry
></row
><row
><entry
><filename
>duarouter/trips/increasing_time_typedefined</filename
></entry
><entry
>same as increasing_time, but a type is given and defined in the trips</entry
></row
><row
><entry
><filename
>duarouter/trips/increasing_time_unsorted</filename
></entry
><entry
>same as increasing_time, but with <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/trips/increasing_time_withcolor</filename
></entry
><entry
>same as increasing_time, a color is given partially</entry
></row
><row
><entry
><filename
>duarouter/trips/one_time</filename
></entry
><entry
>100 trips, one departure time</entry
></row
><row
><entry
><filename
>duarouter/trips/one_time_notype</filename
></entry
><entry
>same as increasing_time, but no type is given in the trips</entry
></row
><row
><entry
><filename
>duarouter/trips/one_time_typedefined</filename
></entry
><entry
>same as increasing_time, but a type is given and defined in the trips</entry
></row
><row
><entry
><filename
>duarouter/trips/one_time_unsorted</filename
></entry
><entry
>the same, but with <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/trips/unsorted_time</filename
></entry
><entry
>100 trips, random departure time, <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/trips/unsorted_time_notype</filename
></entry
><entry
>same as unsorted_time, but no type is given in the trips</entry
></row
><row
><entry
><filename
>duarouter/trips/unsorted_time_typedefined</filename
></entry
><entry
>same as unsorted_time, , but a type is given and defined in the trips</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
><row
><entry
><emphasis
>Checks whether the import of routes (SUMO) works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/routes/increasing_time</filename
></entry
><entry
>100 routes (old style), departure time is increasing</entry
></row
><row
><entry
><filename
>duarouter/routes/one_time</filename
></entry
><entry
>100 routes (old style), one departure time</entry
></row
><row
><entry
><filename
>duarouter/routes/unsorted_time</filename
></entry
><entry
>100 routes (old style), random departure time, <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_withid_increasing_time</filename
></entry
><entry
>100 routes (new style, routes have an id), departure time is increasing</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_withid_one_time</filename
></entry
><entry
>100 routes (new style, routes have an id), one departure time</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_withid_unsorted_time</filename
></entry
><entry
>100 routes (new style, routes have an id), random departure time, <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_noid_increasing_time</filename
></entry
><entry
>100 routes (new style, routes have no id), departure time is increasing</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_noid_one_time</filename
></entry
><entry
>100 routes (new style, routes have no id), one departure time</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_noid_increasing_time</filename
></entry
><entry
>100 routes (new style, routes have no id), random departure time, <option
>--unsorted</option
> set</entry
></row
><row
><entry
><filename
>duarouter/routes/newstyle_increasing_colors</filename
></entry
><entry
>same as newstyle_noid_increasing_time, but colors are supplied partially</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
><row
><entry
><emphasis
>Checks whether the DUA works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>duarouter/dua/newstyle_dua3s_step1</filename
></entry
><entry
>the first step of the dua3s-example using current (new style) output; converts trips to routes and alternatives</entry
></row
><row
><entry
><filename
>duarouter/dua/newstyle_dua3s_step2</filename
></entry
><entry
>the second step of the dua3s-example using current (new style) output; converts alternatives from step 1 to routes and alternatives using weights</entry
></row
><row
><entry
><filename
>duarouter/dua/newstyle_dua3s_step3</filename
></entry
><entry
>the third step of the dua3s-example using current (new style) output; converts alternatives from step 2 to routes and alternatives using weights</entry
></row
><row
><entry
><filename
>duarouter/dua/oldstyle_dua3s_step2</filename
></entry
><entry
>the second step of the dua3s-example using old (style) output; converts alternatives from step 1 to routes and alternatives using weights</entry
></row
><row
><entry
><filename
>duarouter/dua/oldstyle_dua3s_step3</filename
></entry
><entry
>the third step of the dua3s-example using old (style) output; converts alternatives from step 2 to routes and alternatives using weights</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
></tbody
></tgroup
></table
><table
><title
>Tests for NETCONVERT</title
><tgroup
cols="1"
><thead
><row
><entry
>Test Set Description</entry
></row
></thead
><tbody
><row
><entry
><emphasis
>Tests whether showing meta-information works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>netconvert/meta/help</filename
></entry
><entry
>checks whether printing help works</entry
></row
><row
><entry
><filename
>netconvert/meta/version</filename
></entry
><entry
>checks whether printing version works</entry
></row
><row
><entry
><filename
>netconvert/trips/noop</filename
></entry
><entry
>checks what happens when no argument is given</entry
></row
></tbody
></entrytbl
></row
><row
><entry
><emphasis
></emphasis
></entry
></row
><row
><entry
><emphasis
>Checks whether --speed-in-kmh works (in XML)</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>netconvert/XML2/speed_in_kmh/cross_notypes_kmh</filename
></entry
><entry
>no types, speed in kmh</entry
></row
><row
><entry
><filename
>netconvert/XML2/speed_in_kmh/cross_notypes_kmh_v</filename
></entry
><entry
>the same, with verbose output</entry
></row
><row
><entry
><filename
>netconvert/XML2/speed_in_kmh/cross_usingtypes_kmh</filename
></entry
><entry
>types, speed in kmh</entry
></row
><row
><entry
><filename
>netconvert/XML2/speed_in_kmh/cross_usingtypes_kmh_v</filename
></entry
><entry
>the same, with verbose output</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
><row
><entry
><emphasis
>Checks whether types may be used to describe edges (in XML)</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>netconvert/XML2/types/cross_notypes</filename
></entry
><entry
>no types</entry
></row
><row
><entry
><filename
>netconvert/XML2/types/cross_notypes_v</filename
></entry
><entry
>the same, with verbose output</entry
></row
><row
><entry
><filename
>netconvert/XML2/types/cross_usingtypes</filename
></entry
><entry
>with types</entry
></row
><row
><entry
><filename
>netconvert/XML2/types/cross_usingtypes_v</filename
></entry
><entry
>the same, with verbose output</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
><row
><entry
><emphasis
>Checks whether description of edge shapes works (in XML)</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>netconvert/XML2/shapes/hokkaido-japan</filename
></entry
><entry
>a simple test for the hokkaido-network</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
></tbody
></tgroup
></table
><table
><title
>Tests for SUMO</title
><tgroup
cols="1"
><thead
><row
><entry
>Test Set Description</entry
></row
></thead
><tbody
><row
><entry
><emphasis
>Tests whether showing meta-information works</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>sumo/meta/help</filename
></entry
><entry
>checks whether printing help works</entry
></row
><row
><entry
><filename
>sumo/meta/version</filename
></entry
><entry
>checks whether printing version works</entry
></row
><row
><entry
><filename
>sumo/trips/noop</filename
></entry
><entry
>checks what happens when no argument is given</entry
></row
></tbody
></entrytbl
></row
><row
><entry
><emphasis
></emphasis
></entry
></row
><row
><entry
><emphasis
>Checks whether routes are read</emphasis
></entry
></row
><row
><entrytbl
cols="2"
><thead
><row
><entry
>Path</entry
><entry
>Description</entry
></row
></thead
><tbody
><row
><entry
><filename
>sumo/routes/new_style</filename
></entry
><entry
>checks whether newstyle routes are read properly</entry
></row
><row
><entry
><filename
>sumo/routes/old_style</filename
></entry
><entry
>checks whether oldstyle routes are read properly</entry
></row
></tbody
></entrytbl
></row
><row
><entry
></entry
></row
></tbody
></tgroup
></table
></sect2
></sect1
></chapter
></book
>