<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>SUMO - More On... Application Subsystems</title>

    <author>
      <firstname>Christian</firstname>

      <surname>RÃ¶ssel</surname>

      <affiliation>
        <address><email>christian.roessel@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="more_tests">
    <title>Introduction</title>

    <sect1>
      <title>Document Information</title>

      <para>This document is a part of <emphasis>SUMO</emphasis> -
      <emphasis>S</emphasis>imulation of <emphasis>U</emphasis>rban
      <emphasis>MO</emphasis>bility. SUMO is an open source microscopic road
      traffic simulation. It can be found under <ulink
      url="http://sumo.sourceforge.net/">http://sumo.sourceforge.net/</ulink>.</para>

      <para>This document fits to version 0.9.4 We will try to keep it
      up-to-date with the next versions.</para>
    </sect1>

    <sect1>
      <title>Document Scope</title>

      <para>This documentation describes some subsystems which are used within
      most of the applications of the SUMO-package.</para>
    </sect1>

    <sect1>
      <title>Document Audience</title>

      <para>This document contains information for
      <emphasis>developers</emphasis> who want to extend the appications from
      the SUMO-package or who want to write new ones.</para>
    </sect1>

    <sect1>
      <title>Document Structure</title>

      <para>!!!.</para>
    </sect1>
  </chapter>

  <chapter id="dev_chp02">
    <title>Overview on the Application Framework</title>

    <para>Beside some tools, all of the applications within the SUMO-package
    share the same framework, only paramterised with two application-specific
    functions for setting and validating the command line options and the
    configuration settings. This framework initialises the xml-subsystem, the
    options-subsystem and the message handling subsystem.</para>

    <para>The framework was invented to avoid doing the same things for each
    of the package's application once again. All of the applications parse
    command line options and optional a configuration file, they all have to
    initialise and close the XML-subsystem and all use the same paradigm for
    logging messages, either directly to the user via the command line output
    (cout) or by writing a log-file. By sharing the same methods, it is also
    assured, that all applications have almost the same look and feel.</para>

    <sect1>
      <title>The Subsystems' Duties</title>

      <para>The framework may be divided into the following four parts:</para>

      <itemizedlist>
        <listitem>
          <para>The Main Subsystem</para>

          <para>This is a wrapper around the following three
          subsystems.</para>
        </listitem>

        <listitem>
          <para>The XML-Subsystem</para>

          <para>This simply initialises and closes the xerces-XML-parser (both
          being two method calls within a try/catch-block).</para>
        </listitem>

        <listitem>
          <para>The Messaging-Subsystem</para>

          <para>From the version 0.8 on, SUMO is able to generate a log-file
          where all messages, warnings or errors are saved. The messaging
          subsystem is responsible to build the output files, to set the
          report options, such as whether the messages shall be verbose on the
          command line or within the logfile, the same for warnings etc. This
          is done the same way through all applications.</para>
        </listitem>

        <listitem>
          <para>The Options-Subsystem</para>

          <para>A SUMO-application's options may be set both on the command
          line and within a configuration file or both. The options-subsystem
          calls two methods which must be supplied on the main subsystem's
          initialisation. The first one fills the options-container with
          application-dependent options, the second method verifies them after
          they are set with the user's values.</para>
        </listitem>
      </itemizedlist>

      <para>All subsystems will be described more detailed in the following
      chapters.</para>
    </sect1>

    <sect1>
      <title>The Subsystems' Usage</title>

      <para>If you look into the main procedures from the files "*_main.cpp"
      within the top-level source folder, you realise they all look
      similar:<programlisting format="linespecific"
      linenumbering="unnumbered">int
main(int argc, char **argv)
{
    int ret = 0;
#ifndef _DEBUG
    try {
#endif
        <remark>// initialise the application system (messaging, xml, options)</remark>
        int init_ret =
            SystemFrame::init(false, argc, argv, RODUAFrame::fillOptions_fullImport);
        <remark>// check whether any options were given or if a meta-processing option</remark>
        <remark>//  was set</remark>
        if(init_ret&lt;0) {
            <remark>// if something special has happened, proces it</remark>
                <remark>// print the application information first</remark>
            cout &lt;&lt; "SUMO &lt;app_name&gt;" &lt;&lt; endl;
            cout &lt;&lt; " (c) DLR/ZAIK 2000-2006; http://sumo.sourceforge.net" &lt;&lt; endl;
                <remark>// check what has happened</remark>
            switch(init_ret) {
            case -1:
                <remark>// option "--version" was set -&gt; print the version number</remark>
                cout &lt;&lt; " Version " &lt;&lt; version &lt;&lt; endl;
                cout &lt;&lt; " Build #" &lt;&lt; NEXT_BUILD_NUMBER &lt;&lt; endl;
                break;
            case -2:
                <remark>// option "--help" was set -&gt; print the help screen</remark>
                HelpPrinter::print(help);
                break;
            default:
                <remark>// no option was given -&gt; inform user that he has to do something</remark>
                cout &lt;&lt; " Use --help to get the list of options." &lt;&lt; endl;
            }
            <remark>// quit</remark>
            SystemFrame::close();
            return 0;
        <remark>// let's recheck the options</remark>
        <remark>//  maybe an unknown option has been set (init_ret!=0)</remark>
        <remark>//  or maybe the set options are not valid or something is missing</remark>
        <remark>//   (checkOption fails)</remark>
        } else if(init_ret!=0||!RODUAFrame::checkOptions(OptionsSubSys::getOptions())) {
            <remark>// simply throw this (error)</remark>
            throw ProcessError();
        }

        ... application specific stuff ...

#ifndef _DEBUG
    } catch (...) {
        MsgHandler::getErrorInstance()-&gt;inform("Quitting (on error).", false);
        ret = 1;
    }
#endif
    delete net;
    delete loader;
    SystemFrame::close();
    if(ret==0) {
        cout &lt;&lt; "Success." &lt;&lt; endl;
    }
    return ret;
}</programlisting></para>

      <para>The return value is initialised first to "no error" (==0), then,
      within a try/catch-block the subsystem is initialised (using the static
      function<function>SystemFrame::init(bool, int, char**,
      FUNC_fill_options</function>). After checking whether options are valid,
      the application-specific data processing method calls may follow. The
      try/catch-block is needed as we allow each application to throw a
      "ProcessError" allowing easy aborting of the program's execution on any
      place in the case something fails.</para>

      <para>Either after completing the actions or if the
      subsystem-initialisation or the data processing fails, the subsystem is
      closed using <function>SystemFrame::close()</function> (which is a
      static function).</para>

      <para>These two calls wrap all the initialisations described above:
      XML-subsystem initialisation and closing, parsing of command line
      options and/or the configuration file, message subsystem
      initialisation.</para>

      <para>!!!As you see, the pointers to two functions must be
      supplied:</para>

      <formalpara>
        <title>FUNC_fill_options</title>

        <para>Is the function which is called on initialisation of the
        command-line options storage. It is declared as following within
        <function>OptionsSubSys.h</function>:</para>
      </formalpara>

      <para><function>typedef void (fill_options)(OptionsCont
      &amp;);</function></para>

      <para>It receives a reference of options storage to fill. The next
      chapter describes how to insert possible command line options into
      it.</para>

      <formalpara>
        <title>FUNC_check_options</title>

        <para>Is the function which is called on initialisation of the
        command-line options storage. It is declared as following within
        <function>OptionsSubSys.h</function>:</para>
      </formalpara>

      <para><function>typedef bool (check_options)(OptionsCont
      &amp;);</function></para>

      <para>Using the methods to retrieve single options from the options
      storage described within the next chapter, one can check whether the
      user's definitions are proper. The method must return true if
      everything's ok with the user input, otherwise - when a necessary
      network file definition is not given, f.e. , false.</para>
    </sect1>
  </chapter>

  <chapter id="dev_chp03">
    <title>The Options Subsystem</title>

    <para>All major SUMO applications use the same classes for parsing command
    line options and configuration files. Each application has exactly one
    instance of the <function>OptionsCont</function> (options container) -
    class. Before the command line options are parsed, their names, allowed
    types and their default values must be inserted into this container. This
    is done within a method given to the main subsystem as described
    above.</para>

    <para>To insert an application option into the container, use one of the
    following polymorphs:</para>

    <para><function>void doRegister(const std::string &amp;name1, Option
    *v);</function></para>

    <para>or</para>

    <para><function>void doRegister(const std::string &amp;name1, char abbr,
    Option *v);</function></para>

    <para>The parameter "name1" is the name (or one of the possible names,
    better to say) of the inserted option. The character "abbr" within the
    second call is the possible one-char abbreviation of the name.</para>

    <para><caution>
        <para>The behaviour after adding the same abbreviation for two
        different options is not defined.</para>
      </caution></para>

    <para>The third parameter is an option that shall be assigned to the
    name(s). Remark that the <function>OptionsCont</function> takes the
    responsibility for this option - it will be deleted when the
    <function>OptionsCont</function> is deleted. The option itself must be an
    instance of one of the following classes, which all are derived from the
    class <function>Option</function>:</para>

    <itemizedlist>
      <listitem>
        <para><function>Option_Integer</function></para>
      </listitem>

      <listitem>
        <para><function>Option_Long</function></para>
      </listitem>

      <listitem>
        <para><function>Option_String</function></para>
      </listitem>

      <listitem>
        <para><function>Option_Float</function></para>
      </listitem>

      <listitem>
        <para><function>Option_FileName</function></para>
      </listitem>

      <listitem>
        <para><function>Option_UIntVector</function></para>
      </listitem>
    </itemizedlist>

    <para>The names of the classes reflect the types which are awaited for the
    option. Do also remark, that later acces for reading should be done in
    dependence to the type - it means that you should not try to get a string
    from an <function>Option_Float</function>. This yields in an
    exception.</para>

    <para><caution>
        <para>All subclasses of <classname>Option</classname> are stored
        within the files
        <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/utils/options/Option.h</filename>
        and
        <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/utils/options/Option.cpp</filename>.
        This is surely not wished as when following the coding styleguide,
        each class should be stored in a separate pair of files. Also, one
        could imagine to use templates, here.</para>
      </caution></para>

    <para>Every of the option's subclasses has two constructors: one that is
    parametrised with the appropriate type and a parameterless one. The
    parametrised constructor is used to supply default values for options, in
    the other case, no value is known to the system at first. An example:
    settings the "verbose"-switch as following, lets the application run quiet
    as default:</para>

    <programlisting>oc.doRegister("verbose", 'v', new Option_Bool(false));</programlisting>

    <para>Examples of how to insert possible options into their container may
    be found within the files
    <filename>src\sumo_only\SUMOFrame.cpp</filename>,
    <filename>src\gui_main.cpp</filename>,
    <filename>src\od2trips_main.cpp</filename> and
    <filename>src\netbuild\NBOptionsIO.cpp</filename>.</para>

    <para>One can also add synonymes for options. If you want to implement the
    option "<option>name-of-vehicle-that-shall-halt</option>", but you wish to
    have a shorter name, too, use the following to make the same option
    accessable using both "<option>name-of-vehicle-that-shall-halt</option>"
    and "<option>v2h</option>":</para>

    <programlisting format="linespecific">oc.doRegister("name-of-vehicle-that-shall-halt", new Option_String());
oc.addSynonyme("name-of-vehicle-that-shall-halt", "v2h");</programlisting>

    <para>If no default value was supplied for an option, you should ask the
    <classname>OptionsCont</classname> whether it has been set. Access to
    values of unset options causes exceptions. This may sound hard, but as
    it's only the developer who accesses the options container in fact, it's
    the best way to assure security of the code.</para>

    <para>One can check whether a value is available for a certain option
    calling the OptionsCont-member method <function>bool
    isSet("<replaceable>&lt;OPTION_NAME&gt;</replaceable>");</function>. If
    one has to know whether it is the default value given on instantiation of
    the option (see above) or a value supplied by the user, he/she may call
    "<function>bool
    isDefault("<replaceable>&lt;OPTION_NAME&gt;</replaceable>");</function>",
    a member method of <classname>OptionsCont</classname>, too. In dependence
    to the type of an option, one can retrieve her value using the following
    methods from OptionsCont:</para>

    <itemizedlist>
      <listitem>
        <para><function>int
        getInt("<replaceable>&lt;OPTION_NAME&gt;</replaceable>")
        const;</function></para>
      </listitem>

      <listitem>
        <para><function>long
        getLong("<replaceable>&lt;OPTION_NAME&gt;</replaceable>")
        const;</function></para>
      </listitem>

      <listitem>
        <para><function>std::string
        getString("<replaceable>&lt;OPTION_NAME&gt;</replaceable>")
        const;</function></para>
      </listitem>

      <listitem>
        <para><function>float
        getFloat("<replaceable>&lt;OPTION_NAME&gt;</replaceable>")
        const;</function></para>
      </listitem>

      <listitem>
        <para><function>const UIntVector
        &amp;OptionsCont::getUIntVector("<replaceable>&lt;OPTION_NAME&gt;</replaceable>")
        const;</function></para>
      </listitem>
    </itemizedlist>

    <para>Using an inproper method yields in an exception.</para>

    <para>You may have noticed, that there is one method to retrieve a certain
    value less than types available. The type
    "<classname>Option_FileName</classname>" returns a string, too. The only
    difference is their type which allows a different processing of the values
    to set when parsing.</para>

    <para>All classes needed to store and process options can be found within
    <filename><replaceable>&lt;SUMO_DIST&gt;</replaceable>/src/utils/options/</filename></para>

    <para>The process of dealing with options is shown within the next picture
    again:</para>

    <figure>
      <title>Process of options parsing</title>

      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="./gfx/dev/OptionsParsing.gif"
                     format="GIF" />
        </imageobject>
      </mediaobject>
    </figure>
  </chapter>

  <chapter id="dev_chp04">
    <title>Program Flow</title>


      <para>The application within the SUMO-package may be divided into two
      groups: those that are simple command line applications and those that
      have a graphical user interface. The main application flow is almost the
      same for all applications that belong to the same of those groups. Due
      to this, withinthe next two chapters, we will describe briefly both
      flows not regarding each of the applications' special issues at
      first.</para>

      <sect1 id="ProgramFlowWithinCommandLineApplications">
        <title>Program Flow within Command Line Applications</title>

        <para>All command line applications (sumo, duarouter, jtrrouter,
        netconvert, netgen, od2trips) are working quite the same way. At
        first, the subsystem is initialised as described in <!--link
        linkend="TheApplicationSub-system"-->"The application
        sub-system"<!--/link-->. Then, the options are parsed and validated as also
        already described. If the options are invalid or any other error
        occured, a "<exceptionname>ProcessError</exceptionname>" exception is
        thrown and catched within the application's main. This should allow a
        very easy error handling as the application is simply terminating and
        everything that was done until then may be deleted and cleared.</para>

        <para>After the options have been checked, the needed data or the data
        to parse/translate are loaded. The type of the data of course depends
        on the application's purpose but in almost all cases a network the
        data is referenced to is loaded. Also herein, if an error occurs, a
        "<exceptionname>ProcessError</exceptionname>" exception is
        thrown.</para>

        <para>The next step is the processing of the loaded data. In some
        cases, the data are loaded incrementally as they would not fit into
        the memory at once. This is the case for the routes within the
        duarouter (if the <option>--unsorted</option> option is not set) and
        within the simulation (if the <option>--route-steps
        <replaceable>&lt;UINT&gt;</replaceable></option> option is
        set).</para>

        <para>After prepared, data is saved. The last step, which is called in
        both cases - on failure and on access - is the deletion of all
        previously loaded and/or computed data.</para>

        <figure>
          <title>Workflow within command line applications</title>

          <mediaobject>
            <imageobject>
              <imagedata align="center"
                         fileref="./gfx/dev/MainFlowofCommandLineApplications.gif"
                         format="GIF" />
            </imageobject>
          </mediaobject>
        </figure>
    </sect1>
  </chapter>

  <chapter id="dev_chp05">
    <title>Error Handling</title>

      <para>All errors we know about that may happen during the program's
      execution are reported to the user when they occur - despite a memory
      overflow. When an error occurs, the program does not try to solve it as
      we did not encounter errors yet that have any other character than false
      data supplied by the user. Instead, the error is reported and the
      program terminates.</para>

      <para>A developer should respect this paradigm and try to catch every
      false input or situation and report the error to the user providing him
      as many information as available. The further processing may be aborted
      using a "ProcessError" - exception instance, which is caught by the main
      method.</para>

      <para>Warnings may be reported to the user and we in fact have prepared
      an option that should help you determine whether such reports are wished
      or not. Unfortunately, this option is not yet implemented.</para>
  </chapter>
</book>