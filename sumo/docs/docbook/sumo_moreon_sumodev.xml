<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title>SUMO developer documentation</title>

    <author>
      <firstname>Christian</firstname>

      <surname>RÃ¶ssel</surname>

      <affiliation>
        <address><email>christian.roessel@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="dev_chp03">
    <title>SUMO</title>

    <sect1 id="dev_chp03-basics">
      <title>Basics</title>

      <para>SUMO is a command line application and its workflow is the same as
      for others (see <!--link
      linkend="ProgramFlowWithinCommandLineApplications"-->"ProgramFlowWithinCommandLineApplications"<!--/link-->).
      The next two chapter describe some relevant things about data loading
      and about the simulation itself. The next picture shows the packages
      used by SUMO.</para>

      <figure>
        <title>Packages needed by SUMO</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="./gfx/dev/SUMOpackagehierarchy.gif"
                       format="GIF" />
          </imageobject>
        </mediaobject>
      </figure>

      <sect2>
        <title>Basic Philosophy</title>

        <para>We have tried to make the simulation as fast and as lean as
        possible. Due to this, the networks are computed in prior, no further
        network things are computed after the network has bben loaded. We try
        to use fast structures and fast algorithms. Still, you may find some
        things within the code that blow it up. Some functions are assumed to
        be unneeded but are still within the code as they were not removed
        after new methods have been implemented. Furthermore, some of the
        values, mainly within the vehicle and/or the lane classes are just
        some kind of visualisation stuff that should be removed and used
        optionally. This is also the case for color values and some parts of
        the geometrical information as both are not needed within the command
        line version of the simulation. We will try to get rid of these things
        within the future.</para>
      </sect2>
    </sect1>

    <sect1 id="dev_chp03-loading">
      <title>Loading</title>

      <para>The structures to build differ for the command line application
      and the gui-version and may also differ if a new type of application is
      build, for example if the vehicles have to inform an external
      application about their emission or when they leave the network. To
      achieve the creation of different structures from the same description,
      factory classes are used during loading. To set up a loader which
      handles the network and all other structures to use, the following code
      is used, taken from sumo_main.cpp:</para>

      <programlisting format="linespecific" linenumbering="numbered">MSNet * load(OptionsCont &amp;oc)
{
   SharedOutputDevices::setInstance(new SharedOutputDevices());
   SUMOFrame::setMSGlobals(oc);
   MSNet *net = new MSNet(oc.getInt("begin"), oc.getInt("end"));
   NLEdgeControlBuilder eb;
   NLJunctionControlBuilder jb(oc);
   NLDetectorBuilder db(*net);
   NLTriggerBuilder tb;
   NLGeomShapeBuilder sb;
   NLHandler handler("", *net, db, tb, eb, jb, sb);
   NLNetBuilder builder(oc, *net, eb, jb, db, tb, sb);
   if(!builder.build()) {
      delete net;
      net = 0;
  }
  return net;
}</programlisting>

      <para>So what we do here is the following:</para>

      <itemizedlist>
        <listitem>
          <para>Set up a handler for our output devices</para>
        </listitem>

        <listitem>
          <para>Set global variables using the current options</para>
        </listitem>

        <listitem>
          <para>Prebuild the net; it will be filled during the build
          process</para>
        </listitem>

        <listitem>
          <para>Build a factory for edge building</para>
        </listitem>

        <listitem>
          <para>Build a factory for junction building</para>
        </listitem>

        <listitem>
          <para>Build a factory for detector building</para>
        </listitem>

        <listitem>
          <para>Build a factory for trigger building</para>
        </listitem>

        <listitem>
          <para>Build a factory for building geometrical shapes</para>
        </listitem>

        <listitem>
          <para>Build a network handler which uses the given factories and
          options and which fills the given net (they are given to the handler
          as references)</para>
        </listitem>

        <listitem>
          <para>Build a network builder which uses the given factories to
          close the building</para>
        </listitem>

        <listitem>
          <para>Try to build the network using the builder</para>
        </listitem>

        <listitem>
          <para>If it fails: delete the net, mark it as 0 (no net was
          build)</para>
        </listitem>

        <listitem>
          <para>Return the build net or 0</para>
        </listitem>
      </itemizedlist>

      <figure>
        <title>State diagram of data loading</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="./gfx/dev/SUMOLoading.gif"
                       format="GIF" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>Briefly described, this set of building structures works as
      follows: The builder opens the network file, the route files and the
      additional files in this order and parses them using a build handler
      (see [!!!]). The handler retrieves information from the file and
      preprocesses them in order to get C++-typed values. This is for example
      necessary, if one uses XML-files and the values have to be translated
      from XML-Text to ints, floats, and so on. While doing this, the handler
      checks whether necessary data is supplied within the description and
      whether it can be converted into the proper types. The parsed values are
      given to a factory using which the current element. shall be build. This
      factory then uses the given values to build SUMO-structures. Almost the
      same is done within the gui version, but the factories change (see
      tbd).</para>

      <sect2>
        <title>The Procedures</title>

        <para>Loading of the network, the routes and other data follows the
        philosophy of avoiding allocation of unnecessary memory. Due to this,
        the network format resembles SUMO's internal network description and
        the data is loaded in the same order as used on initialisation. As
        several things have to know about other, this is not that
        straightforward and due to this documented herein. The process is as
        following:</para>

        <procedure>
          <step>
            <para>Load edge names, initialise edges using their id (from
            <sgmltag>&lt;edges&gt;</sgmltag>)</para>

            <para><emphasis>Builds</emphasis>: preinitialised (uncomplete
            edges)</para>

            <para><emphasis>Needs</emphasis>: nothing</para>
          </step>

          <step>
            <para>Allocate place for junctions (not necessary, but saves some
            memory) (from <sgmltag>&lt;node_count&gt;</sgmltag>)</para>

            <para><emphasis>Builds</emphasis>: nothing (initialises the size
            only)</para>

            <para><emphasis>Needs</emphasis>: nothing</para>
          </step>

          <step>
            <para>For each edge (element
            <sgmltag>&lt;edge&gt;</sgmltag>):</para>

            <procedure>
              <step>
                <para>Parse and allocate the lanes; assign lanes to the edge
                (from <sgmltag>&lt;lane&gt;</sgmltag>)</para>

                <para><emphasis>Builds</emphasis>: lanes</para>

                <para><emphasis>Needs</emphasis>: nothing</para>
              </step>

              <step>
                <para>Parse and allocate connections from the edge to another
                edge (from <sgmltag>&lt;cedge&gt;</sgmltag>)</para>

                <para><emphasis>Builds</emphasis>: map: succeeding edge -&gt;
                current edge's lanes reaching it</para>

                <para><emphasis>Needs</emphasis>: preinitialised edges,
                current edge's lanes</para>
              </step>

              <step>
                <para>Build the edge</para>

                <para><emphasis>Builds</emphasis>: complete edge</para>

                <para><emphasis>Needs</emphasis>: this edge's lanes,
                connections</para>
              </step>
            </procedure>
          </step>

          <step>
            <para>Parse and build row-logics (element
            <sgmltag>&lt;row-logic&gt;</sgmltag>)</para>

            <para><emphasis>Builds</emphasis>: right of way - logics</para>

            <para><emphasis>Needs</emphasis>: Nothing</para>
          </step>

          <step>
            <para>Parse and build tls-logics (element
            <sgmltag>&lt;tl-logic&gt;</sgmltag>)</para>

            <para><emphasis>Builds</emphasis>: traffic light logics -
            logics</para>

            <para><emphasis>Needs</emphasis>: Nothing for static tls; may need
            incoming lanes if required</para>
          </step>

          <step>
            <para>Parse and build junctions (element
            <sgmltag>&lt;junction&gt;</sgmltag>)</para>

            <para><emphasis>Builds</emphasis>: junctions - logics</para>

            <para><emphasis>Needs</emphasis>: row-logics, tls-logics</para>
          </step>

          <step>
            <para>Parse succeding edges and link types</para>

            <para><emphasis>Builds</emphasis>: lane-to-lane links</para>

            <para><emphasis>Needs</emphasis>: tls-logics, lanes</para>
          </step>
        </procedure>
      </sect2>

      <sect2>
        <title>The Classes</title>

        <para>We will now describe the builder, the handler and the factories
        more detailed.</para>

        <sect3>
          <title>The Builder (NLBuilder!!!)</title>

          <para>As said before, the builder is used to start parsing
          information using the handler. It does this as following:</para>

          <procedure>
            <step>
              <para>Load the network (call to "load" with the network name
              from options and the information that the net shall be
              loaded)</para>
            </step>

            <step>
              <para>Build the network</para>
            </step>

            <step>
              <para>Load the state dump if wished</para>
            </step>

            <step>
              <para>Load the routes if wished and if they shall not be
              processed stepwise (call to "load" with the route file name(s)
              from options and the information that routes shall be
              loaded)</para>
            </step>

            <step>
              <para>Load additional structures if wished (call to "load" with
              the additional file name(s) from options and the information
              that additional structures shall be loaded)</para>
            </step>
          </procedure>

          <para>As easy as it sounds, this procedure is usable for all
          derivations of the network (at least until now). The "load" function
          determines an appropriate handler to use (see [!!!]), builds it,
          tells it what to parse and starts to process the files.</para>
        </sect3>

        <sect3>
          <title>The Handlers (NLHandler, MSRouteHandler and
          derivates)</title>

          <para>We do not handle binary inputs, yet. This allows us to use a
          handler derived from MSRouteHandler, which is responsible for
          loading routes to parse all other data stored in XML. The advantage
          is that we may use the same handler for all other files, which
          allows the user to specify the simulation as flexible as
          possible.</para>

          <para>Based on this, the handler is a SAXHandler indirectly derived
          from XERCES's DefaultHandler. It obtains the events
          <methodname>startElement</methodname>,
          <methodname>endElement</methodname> and
          <methodname>characters</methodname>, but not directly, but preparsed
          by the
          <classname>AttributesReadingGenericSAX2Handler</classname>-methods,
          which tranfer the UTF-16 element names and attributes into strings
          and enums (see [!!!]). This means, that instead of
          <methodname>startElement</methodname>,
          <methodname>endElement</methodname> and
          <methodname>characters</methodname>, the methods
          <methodname>myStartElement</methodname>,
          <methodname>myEndElement</methodname> and
          <methodname>myCharacters</methodname> are used.</para>

          <para>Within these methods if-statements decide which data may be
          parsed. So if for example the builder said the handler to build the
          network, no additional elements will be build. Within these
          statements, case-trees decide what to do further with the
          information the occured element contains.</para>

          <para>A derived version of the handler for the gui
          (<classname>GUIHandler</classname>) additionally parses color
          information and junction geometries from the input files.</para>
        </sect3>

        <sect3>
          <title>The Factories</title>

          <para>... to be described ...</para>

          <sect4>
            <title>Edge Builder (NLEdgeControlBuilder and derivates)</title>

            <para>Used to build edges and lanes, this class' method
            <methodname>MSEdgeControl
            *NLEdgeControlBuilder::build()</methodname> builds an edge control
            used by the simulation (see [!!!]). The inline documentation says
            furthermore:</para>

            <para><citation>This class is the container for MSEdge-instances
            while they are build.</citation></para>

            <para><citation>As instances of the MSEdge-class contain
            references to other instances of this class which may not yet be
            known at their generation, they are prebuild first and initialised
            with their correct values in a second step.</citation></para>

            <para><citation>While building an intialisation of the MSEdge, the
            value are stored in a preallocated list to avoid memory fraction.
            For the same reason, the list of edges, later splitted into two
            lists, one containing single-lane-edges and one containing
            multi-lane-edges, is preallocated to the size that was previously
            computed by counting the edges in the first parser step. As a
            result, the build MSEdgeControlBuilder is
            returned.</citation></para>

            <para>Methods that may be overriden for building classes derived
            from microsim-classes are shown in the next table. New
            implementations may be found for example within
            <classname>GUIEdgeControlBuilder</classname>.</para>

            <table>
              <title>Methods to derive</title>

              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Method</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><methodname>MSEdge *
                    NLEdgeControlBuilder::addEdge(const string
                    &amp;id)</methodname></entry>

                    <entry>Builds the edges</entry>
                  </row>

                  <row>
                    <entry>MSLane * NLEdgeControlBuilder::addLane(const
                    std::string &amp;id, double maxSpeed, double length, bool
                    isDepart, const Position2DVector &amp;shape)</entry>

                    <entry>Builds the lanes</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </sect4>

          <sect4>
            <title>Links Builder (NLSucceedingLaneBuilder)</title>

            <para>Used to build the connections between lanes. Implementation
            of derived classes was not yet needed.</para>
          </sect4>

          <sect4>
            <title>Junction Builder (NLJunctionControlBuilder and
            derivates)</title>

            <para>Used to build junctions and their logics, both right-of-way
            and traffic light system logics, this class' methods
            <methodname>MSJunctionControl *
            NLJunctionControlBuilder::build()</methodname> and
            <methodname>MSTLLogicControl *
            NLJunctionControlBuilder::buildTLLogics() const</methodname> build
            the junction control and the traffic lights control, respectively.
            The inline documentation says furthermore:</para>

            <para><citation>NLJunctionControlBuilder is a factory for
            MSJunction-instances while their building until they are
            transfered into a MSJunctionControl-instance at
            last.</citation></para>

            <para><citation>To avoid memory fraction, the list of the
            MSJunction-instances is preallocated to the counted number of
            MSJunctions int he XML-file. The result is a
            MSJunctionControl-instance holding the parsed
            MSJunction-instances.</citation></para>

            <para>Methods that may be overriden for building classes derived
            from microsim-classes are shown in the next table. New
            implementations may be found for example within
            <classname>GUIJunctionControlBuilder</classname>. Remind, that
            this gui-version also obtains the junctions' shapes within
            <methodname>void GUIJunctionControlBuilder::addJunctionShape(const
            Position2DVector &amp;shape)</methodname> and uses them while
            building the junctions.</para>

            <table>
              <title>Methods to derive</title>

              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Method</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><methodname>MSJunction *
                    NLJunctionControlBuilder::buildNoLogicJunction()</methodname></entry>

                    <entry>Builds a junction with no logic</entry>
                  </row>

                  <row>
                    <entry>MSJunction *
                    NLJunctionControlBuilder::buildLogicJunction()</entry>

                    <entry>Builds a junction with a logic</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </sect4>

          <sect4>
            <title>Detector Builder (NLDetectorBuilder and derivates)</title>

            <para>Because detectors may be build while loading additional
            files and also while building junctions, this builder does not
            create the corresponding microsim control
            (<classname>MSDetectorControl</classname>) but fills an instance
            of this class which was prebuild while building the
            network.</para>

            <para>Methods that may be overriden for building classes derived
            from microsim-classes are shown in the next table. New
            implementations may be found for example within
            <classname>GUIDetectorBuilder</classname>.</para>

            <table>
              <title>Methods to derive</title>

              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Method</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><methodname>MSInductLoop *
                    NLDetectorBuilder::createInductLoop(const std::string
                    &amp;id, MSLane *lane, double pos, int
                    splInterval)</methodname></entry>

                    <entry>Builds a <classname>MSInductLoop</classname> or a
                    derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>MSE2Collector *
                    NLDetectorBuilder::createSingleLaneE2Detector(const
                    std::string &amp;id, DetectorUsage usage, MSLane *lane,
                    double pos, double length, MSUnit::Seconds
                    haltingTimeThreshold, MSUnit::MetersPerSecond
                    haltingSpeedThreshold, MSUnit::Meters jamDistThreshold,
                    SUMOTime deleteDataAfterSeconds) </methodname></entry>

                    <entry>Builds a <classname>MSE2Collector</classname> or a
                    derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>MS_E2_ZS_CollectorOverLanes *
                    NLDetectorBuilder::createMultiLaneE2Detector(const
                    std::string &amp;id, DetectorUsage usage, MSLane *lane,
                    double pos, MSUnit::Seconds haltingTimeThreshold,
                    MSUnit::MetersPerSecond haltingSpeedThreshold,
                    MSUnit::Meters jamDistThreshold, SUMOTime
                    deleteDataAfterSeconds) </methodname></entry>

                    <entry>Builds a
                    <classname>MS_E2_ZS_CollectorOverLanes</classname> or a
                    derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>MSE3Collector *
                    NLDetectorBuilder::createE3Detector(const std::string
                    &amp;id, const Detector::CrossSections &amp;entries, const
                    Detector::CrossSections &amp;exits, MSUnit::Seconds
                    haltingTimeThreshold, MSUnit::MetersPerSecond
                    haltingSpeedThreshold, SUMOTime deleteDataAfterSeconds)
                    </methodname></entry>

                    <entry>Builds a <classname>MSE3Collector</classname> or a
                    derived class</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </sect4>

          <sect4>
            <title>Trigger Builder (NLTriggerBuilder and derivates)</title>

            <para>Build triggers are added directly to the net just as
            detectors are.</para>

            <para>Methods that may be overriden for building classes derived
            from microsim-classes are shown in the next table. New
            implementations may be found for example within
            <classname>GUITriggerBuilder</classname>.</para>

            <table>
              <title>Methods to derive</title>

              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Method</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><methodname>MSLaneSpeedTrigger *
                    GUITriggerBuilder::buildLaneSpeedTrigger(MSNet &amp;net,
                    const std::string &amp;id, const
                    std::vector&lt;MSLane*&gt; &amp;destLanes, const
                    std::string &amp;file)</methodname></entry>

                    <entry>Builds a<classname>MSLaneSpeedTrigger</classname>
                    or a derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>MSTriggeredEmitter *
                    GUITriggerBuilder::buildLaneEmitTrigger(MSNet &amp;net,
                    const std::string &amp;id, MSLane *destLane, double pos,
                    const std::string &amp;file) </methodname></entry>

                    <entry>Builds a <classname>MSTriggeredEmitter</classname>
                    or a derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>MSTriggeredRerouter *
                    GUITriggerBuilder::buildRerouter(MSNet &amp;net, const
                    std::string &amp;id, std::vector&lt;MSEdge*&gt;
                    &amp;edges, float prob, const std::string &amp;file)
                    </methodname></entry>

                    <entry>Builds a <classname>MSTriggeredRerouter</classname>
                    or a derived class</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </sect4>

          <sect4>
            <title>Geometrical Shape Builder (NLGeomShapeBuilder and
            derivates)</title>

            <para>This is a simple factory for building geometrical shapes
            that may be displayed in addition to the net (see [!!!]). Its
            method <methodname>ShapeContainer
            *NLGeomShapeBuilder::buildShapeContainer()</methodname> const
            builds a shape container which is assigned to the net.</para>

            <para>Methods that may be overriden for building classes derived
            from microsim-classes are shown in the next table. New
            implementations may be found for example within
            <classname>GUITriggerBuilder</classname>.</para>

            <table>
              <title>Methods to derive</title>

              <tgroup cols="2">
                <thead>
                  <row>
                    <entry>Method</entry>

                    <entry>Description</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><methodname>void
                    GUIGeomShapeBuilder::polygonEnd(const Position2DVector
                    &amp;shape) </methodname></entry>

                    <entry>Builds a <classname>Polygon2D</classname> or a
                    derived class</entry>
                  </row>

                  <row>
                    <entry><methodname>void
                    GUIGeomShapeBuilder::addPoint(const std::string &amp;name,
                    const std::string &amp;type, const RGBColor &amp;c, float
                    x, float y) </methodname></entry>

                    <entry>Builds a <classname>PointOfInterest</classname> or
                    a derived class</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </sect4>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Simulation</title>

      <para>... to be described ...</para>

      <sect2>
        <title>Detectors</title>

        <para>In the following sections we will describe SUMOs way to
        communicate with it's two kinds of detectors, the <link
        linkend="ExtendedDetectors"><emphasis>extended</emphasis></link> ones,
        that work on an area of a lane and the <link
        linkend="UnextendedDetectors"><emphasis>unextended</emphasis></link>
        ones, that measure at a fixed position on a lane.</para>

        <sect3 id="DetectorCommunication">
          <title>Communication between detectors and SUMO</title>

          <para>Detectors are nearly independant from the rest of the
          simulation. In the simulation loop there is just on call to a static
          method before the emission and the move of the vehicles, and one
          call afterwards. The moving vehicles inform the detectors that they
          have entered or left the detector through
          <emphasis>move-reminder</emphasis>-objects. These move-reminders
          have to be provided for each detector. They are instances of small
          classes, that just check for some condition, e.g. the position of
          the vehicle (you can check for whatever a vehicle provides). All
          move-reminders inherit from <literal>MSMoveReminder</literal>. If a
          condition is met, the reminder informs the detector. All data is
          collected in the detector-object. And all processing is done there,
          too. So if you want a special purpose detector, you have to write
          the detector-class and a corresponding reminder-class.</para>

          <para>But how do the vehicles know about the move-reminders? On
          creation of a detector object, a reminder-object is created too. It
          is passed to the lane the detector works on. The lane has a
          container of move-reminder objects. If a vehicle enters a lane it
          gets a copy of this container. At every move, the vehicle calls the
          method <literal>workOnMoveReminders()</literal>. In this call all
          reminders are asked if they are <literal>isStillActive()</literal>.
          If not, they are removed from the vehicles move-reminder container,
          otherwise the detector may be called. The move-reminders have just
          two additional methods for entering and leaving the lane. Their
          names are quite self-explanatory:
          <literal>isActivatedByEmitOrLaneChange()</literal> and
          <literal>dismissByLaneChange()</literal>.</para>

          <para>Note that the interfaces of detector classes may differ
          completely. The detector methods that collect data are called by
          their associated reminders only. There is no need to inherit from a
          base detector.</para>
        </sect3>

        <sect3 id="ExtendedDetectors">
          <title>Extended detectors</title>

          <para>In real life the <emphasis>extended</emphasis> detectors are
          realized by headover detectors, like video-cameras on helicopters,
          bridges, zeppelins. They collect data from an area of a lane. They
          are ideal to measure <emphasis>densities</emphasis>, because
          densities are area-measured quantities. They are also the first
          choice to measure <emphasis>travelcosts</emphasis>. In this case the
          extended detector covers the lane completely. Sophisticated
          <emphasis>traffic-signal sequencing</emphasis> depends also on
          extended detectors.</para>

          <sect4>
            <title>The <literal>MSLaneState</literal> detector</title>

            <para>Currently there is only one extended detector:
            <literal>MSLaneState</literal>. This detector covers a part of a
            lane and collects basic vehicle data, like speed, entry- and
            leavetime. It provides following methods to get information about
            the current state of the detector:</para>

            <itemizedlist>
              <listitem>
                <literallayout><literal>int getCurrentNumberOfWaiting( void )</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getCurrentMeanSpeed( void );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getCurrentMeanSpeedSquare( void );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getCurrentDensity( void );</literal></literallayout>
              </listitem>
            </itemizedlist>

            <para>To get averaged detector data (averaged over
            <literal>lastNTimesteps</literal>) you can call the following
            methods:</para>

            <itemizedlist>
              <listitem>
                <literallayout><literal>double getNumberOfWaiting( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getMeanSpeed( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getMeanSpeedSquare( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getMeanDensity( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>double getMeanTraveltime( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>int getNVehContributed( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>int getNVehEnteredDetector( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>int getNVehLeftDetectorByMove( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>int getNVehPassedEntireDetector( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>std::string getXMLOutput( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>
            </itemizedlist>

            <note>
              <para>Note that there is a upper limit for
              <literal>lastNTimesteps</literal>. In order to save memory, the
              collected data is stored for a bounded interval only. You can
              adjust this bound through the <literal>MSLaneState</literal>
              constructor-parameter <literal>deleteDataAfterSeconds</literal>.
              The default is 15 minutes. The deletion is triggerd by
              <literal>MSEventControl</literal>.</para>
            </note>

            <para>For more details on this class see the files
            <literal>MSLaneState.h</literal> and
            <literal>MSLaneState.cpp</literal>.</para>
          </sect4>

          <sect4 id="TravelcostDetectors">
            <title>Extended detectors as travelcost detectors</title>

            <para>If you want to measure travelcosts, you usually put an
            extended detector on every lane, aggregate the collected data over
            a fixed interval and write this data to a file. This is, what
            <literal>MSTravelcostDetector</literal> provides.
            <literal>MSTravelcostDetector</literal> is a template singleton
            class. The template parameter is the extended detector to use. So
            if you call <literal>MSTravelcostDetector&lt; MSLaneState
            &gt;::create( maxIntervalLength )</literal>.
            <literal>MSTravelcostDetector</literal> creates
            <literal>MSLaneState</literal> detectors on every lane, covering
            the lanes completety. Then you can add sample intervals from 1 to
            maxIntervalLength seconds (call e.g.
            <literal>MSTravelcostDetector&lt; MSLaneState
            &gt;::getInstance()-&gt;addSampleInterval( 60 )</literal>, which
            adds a 60 seconds interval. The collected data will be written in
            a file called <literal>MSLaneState_60.xml</literal>).</para>

            <para>The sampling for a specific interval is triggered by
            <literal>MSEventControl</literal>.</para>

            <para>An extended detector class must provide following methods to
            be a proper template parameter to
            <literal>MSTravelcostDetector</literal>:</para>

            <itemizedlist>
              <listitem>
                <literallayout><literal>static std::string getNamePrefix( void );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>static std::string&amp; getXMLHeader( void );</literal></literallayout>
              </listitem>

              <listitem>
                <literallayout><literal>std::string getXMLOutput( MSNet::Time lastNTimesteps );</literal></literallayout>
              </listitem>
            </itemizedlist>

            <para>For an example see <literal>MSLaneState</literal>.</para>
          </sect4>
        </sect3>

        <sect3 id="UnextendedDetectors">
          <title>Unextended detectors</title>

          <para>The real life counterpart of <emphasis>unextended
          detectors</emphasis> are induction loops. They collect data from a
          fixed position on a lane when a vehicle passes by. They are
          predestined for <emphasis>flow measurments</emphasis>.</para>

          <note>
            <para>The MSinductionLoop class has to be modified to use the
            move-reminder concept. The documentation will be added if this
            task is completed.</para>
          </note>
        </sect3>
      </sect2>
    </sect1>

    <sect1>
      <title>Output</title>

      <para>... to be described ...</para>
    </sect1>

    <sect1>
      <title>Closing</title>

      <para>... to be described ...</para>
    </sect1>
  </chapter>
</book>