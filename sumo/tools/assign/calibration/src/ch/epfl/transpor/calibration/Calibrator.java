/*
 * Do not distribute this software. It is property of
 * 
 *   Gunnar Flötteröd
 *   Transport and Mobility Laboratory
 *   Ecole Polytechnique Fédérale de Lausanne
 *
 * Please mention explicitly the use of this software when publishing results.
 *
 * This software is provided WITHOUT ANY WARRANTY; without even the implied 
 * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Nor myself
 * neither my employer (EPFL) shall be liable for any damage of any kind in 
 * connection with the use of this software.
 * 
 */
package ch.epfl.transpor.calibration;

import java.io.PrintStream;
import java.io.Serializable;
import java.util.Random;

import ch.epfl.transpor.calibration.demand.Plan;
import ch.epfl.transpor.calibration.statistics.Statistic;
import ch.epfl.transpor.calibration.statistics.StatisticsDisposer;
import ch.epfl.transpor.calibration.supply.RegressionBasedAnalyzer;
import ch.epfl.transpor.calibration.supply.SimResultsContainer;

/**
 * 
 * This is the basic calibration class. It is abstract because the most
 * efficient mechanics of plan selection are likely to differ among DTA
 * simulators. Consequently, a subclass that suits the particular application's
 * needs should be instantiated. The set of such subclasses is expected to grow
 * with the different applications of this tool.
 * 
 * @param L
 *            the network link type
 * @param S
 *            the type of the concrete individual-level plan sampler
 * 
 * @author Gunnar Flötteröd
 * 
 */
public class Calibrator<L, S> implements Serializable {

	// -------------------- SERIALIZABLE IMPLEMENTATION --------------------

	private static final long serialVersionUID = 1L;

	/**
	 * builds by regression a linear log-likelihood model
	 */
	private RegressionBasedAnalyzer<L, Plan<L>> analyzer;

	public void setAnalyzer(RegressionBasedAnalyzer<L, Plan<L>> analyzer) {
		this.analyzer = analyzer;
	}

	public RegressionBasedAnalyzer<L, Plan<L>> getAnalyzer() {
		return this.analyzer;
	}

	/**
	 * provides reproducible randomization
	 */
	private Random random;

	public void setRandom(Random random) {
		this.random = random;
	}

	public Random getRandom() {
		return random;
	}

	/**
	 * provides basic inference about demand parameters
	 * 
	 * TODO: (1) test
	 * 
	 * TODO: (2) serialize when tested
	 */
	private transient StatisticsDisposer<L> statisticsDisposer;

	/**
	 * number of preparatory iterations, must be at least two (to properly
	 * initialize the regression-based log-likelihood linearization)
	 */
	private int preparatoryIterations = 5;

	public void setPreparatoryIterations(int preparatoryIterations) {
		if (preparatoryIterations < 2) {
			throw new IllegalArgumentException(
					"number of preparatory iterations must be at least 2");
		}
		this.preparatoryIterations = preparatoryIterations;
	}

	public int getPreparatoryIterations() {
		return this.preparatoryIterations;
	}

	/**
	 * the iteration from which on the calibrator assumes stationary conditions
	 * and thus stabilizes all of its parameters. Must not be negative and is
	 * strongly dependent on the problem at hand.
	 */
	private int freezeIteration = Integer.MAX_VALUE;

	public void setFreezeIteration(int freezeIteration) {
		if (freezeIteration < 0) {
			throw new IllegalArgumentException(
					"freeze iteration must at least be 0");
		}
		this.freezeIteration = freezeIteration;
		if (this.iteration >= this.freezeIteration) {
			this.analyzer.freeze();
		}
	}

	public int getFreezeIteration() {
		return this.freezeIteration;
	}

	/**
	 * the PrintStream to which all messages of the calibrator are sent. Must
	 * not be null.
	 */
	private PrintStream messageStream = System.out;

	public void setMessageStream(PrintStream messageStream) {
		if (messageStream == null) {
			throw new IllegalArgumentException(
					"Message stream must not be null.");
		}
		this.messageStream = messageStream;
	}

	public PrintStream getMessageStream() {
		return this.messageStream;
	}

	/**
	 * the String prefix of all message lines that are generated by the
	 * calibrator. May be null.
	 */
	private String messagePrefix = "Calibration: ";

	public void setMessagePrefix(String messagePrefix) {
		this.messagePrefix = (messagePrefix == null ? "" : messagePrefix);
	}

	public String getMessagePrefix() {
		return this.messagePrefix;
	}

	/**
	 * the current iteration of the calibrator. Identical to the number of times
	 * afterNetworkLoading(..) has been called.
	 */
	private int iteration = 0;

	public void setIteration(int iteration) {
		this.iteration = iteration;
	}

	public int getIteration() {
		return this.iteration;
	}

	/**
	 * Same as the standard constructor with a newly generated Random instance
	 * and a lambda forgetting factor of 0.95. This constructor provides a
	 * meaningful setup (it is not only for serialization).
	 */
	public Calibrator() {
		this(new Random(), 0.95);
	}

	// -------------------- CONSTRUCTION --------------------

	/**
	 * Standard constructor. Instantiate one Calibrator subclass for an entire
	 * calibration process.
	 * 
	 * @param rnd
	 *            provides control over reproducible random number generation
	 * @param lambda
	 *            forgetting factor of the recursive regression log-likelihood
	 *            approximation
	 * 
	 */
	public Calibrator(final Random rnd, final double lambda) {
		this.analyzer = new RegressionBasedAnalyzer<L, Plan<L>>(0, 3600, 24,
				lambda);
		this.setRandom(rnd);
		this.statisticsDisposer = new StatisticsDisposer<L>(10);
	}

	// -------------------- SIMPLE FUNCTIONALITY --------------------

	/**
	 * @param msg
	 *            this String is prefixed and sent to the message stream the
	 *            calibrator is configured with
	 */
	public void printMessage(final String msg) {
		this.getMessageStream().println(this.getMessagePrefix() + msg);
	}

	// -------------------- IMPLEMENTATION --------------------

	// protected StatisticsDisposer<L> getStatisticsDisposer() {
	// return this.statisticsDisposer;
	// }

	protected double calcLinearPlanEffect(final Plan<L> plan) {
		if (this.getIteration() < this.getPreparatoryIterations()) {
			return 0;
		} else {
			return this.analyzer.calcPlanLambda(plan);
		}
	}

	protected void addToDemand(final Plan<L> plan) {
		this.analyzer.addToDemand(plan);
	}

	/**
	 * Allows to add plan parameter statistics to the calibration. All
	 * statistics should be added to the Calibrator before the calibration
	 * itself is started. Care is internally taken to evaluate these statistics
	 * only in stationary conditions.
	 * 
	 * @param stat
	 *            a statistic that is to be evaluated in the course of this
	 *            calibration
	 */
	public void addStatistic(Statistic<L> stat) {
		this.statisticsDisposer.addStatistic(stat);
	}

	/**
	 * Allows to register flow measurements with the calibration. Every flow
	 * measurement that is to be accounted for must be registered once before
	 * the calibration starts.
	 * <p>
	 * Currently, the underlying measurement model is one of univariate and
	 * normally distributed measurements. That is, correlations between sensors
	 * are not yet accounted for.
	 * 
	 * @param link
	 *            a link instance of type L on which the flow measurement is
	 *            available
	 * @param start_s
	 *            the start time of the measurement (in seconds after midnight)
	 * @param end_s
	 *            the end time of the measurement (in seconds after midnight)
	 * @param val_veh_h
	 *            the measured flow (in vehicles per hour)
	 * @param stddev_veh_h
	 *            the standard deviation of this measurement (in vehicles per
	 *            hour)
	 */
	public void addFlowMeasurement(final L link, final int start_s,
			final int end_s, final double val_veh_h, final double stddev_veh_h) {
		// CHECKS are done in analyzer
		this.analyzer.addFlowMeasurement(link, start_s, end_s, val_veh_h,
				stddev_veh_h);
	}

	/**
	 * Must be called exactly once after every network loading.
	 * 
	 * @param simResults
	 *            a SimResultsContainer implementation that provides access to
	 *            the simulation results of the most recent network loading.
	 */
	public void afterNetworkLoading(final SimResultsContainer<L> simResults) {
		if (this.iteration >= this.freezeIteration) {
			this.analyzer.freeze();
		}
		this.analyzer.afterNetworkLoading(simResults);
		this.iteration++;
		this.printMessage(this.analyzer.getInfoString());
	}
}