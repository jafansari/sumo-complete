/***************************************************************************
                          MSVehicle.icc  -  Base for all
                          micro-simulation Vehicles.
                             -------------------
    begin                : Mon, 05 Mar 2001
    copyright            : (C) 2001 by ZAIK http://www.zaik.uni-koeln.de/AFS
    author               : Christian Roessel
    email                : roessel@zpr.uni-koeln.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// $Log$
// Revision 1.5  2003/04/10 15:43:44  dkrajzew
// emission on non-source lanes debugged
//
// Revision 1.4  2003/04/07 12:12:39  dkrajzew
// eps reduced for small segments (dawdle2)
//
// Revision 1.3  2003/02/07 10:41:50  dkrajzew
// updated
//
// Revision 1.2  2002/10/16 16:45:42  dkrajzew
// debugged
//
// Revision 1.1  2002/10/16 14:48:26  dkrajzew
// ROOT/sumo moved to ROOT/src
//
// Revision 1.3  2002/07/31 17:33:01  roessel
// Changes since sourceforge cvs request.
//
// Revision 1.4  2002/07/31 14:42:34  croessel
// Use of new VehicleType methods.
//
// Revision 1.3  2002/07/03 16:00:22  croessel
// New method gap2pred.
//
// Revision 1.2  2002/06/19 15:07:54  croessel
// Added method timeHeadWayGap( speed ) to forbid timeheadway < deltaT states.
//
// Revision 1.1  2002/05/29 17:09:22  croessel
// Initial commit.
//

/**************** INCLUDE HEADER FILES HERE ********************************/


#include "MSLane.h"
#include "MSEdge.h"
#include "MSVehicleType.h"
#include "MSNet.h"
#include <iostream>
#include <cassert>
#include <cmath>
#include <cstdlib>
#include <algorithm>


/**************** DO NOT INCLUDE ANYTHING AFTER THIS POINT *****************/
#ifdef DISABLE_INLINE
#define inline
#endif

/**************** DEFINE INLINE FUNCTIONS HERE *****************************/

inline
double
MSVehicle::dawdle( double speed ) const
{
    // generate random number out of [0,1]
    double random = double( rand() ) / double( RAND_MAX );

    // Dawdle.
    // TODO:
    // We already have a safe speed, if we dawdle max, is it possible
    // to reduce the speed 2*decel?
    speed -= myType->dawdle() * myType->accelSpeed() * random;

    return max( double( 0 ), speed );
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::dawdle2( double speed ) const
{
    // generate random number out of [0,1]
    double random = double( rand() ) / double( RAND_MAX );

    // Dawdle.
    // TODO:
    // We already have a safe speed, if we dawdle max, is it possible
    // to reduce the speed 2*decel?
    speed -= myType->dawdle() * speed * random;

    return max( double( 0 ), speed );
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::tau()
{
    return myTau;
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::pos() const
{
    return myState.myPos;
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::length() const
{
    return myType->length();
}

/////////////////////////////////////////////////////////////////////////////

inline
bool
MSVehicle::overlap( const MSVehicle* veh1, const MSVehicle* veh2 )
{
    if ( veh1->myState.myPos < veh2->myState.myPos ) {

        return veh2->myState.myPos - veh2->myType->myLength <
               veh1->myState.myPos;
    }
    return veh1->myState.myPos - veh1->myType->myLength <
           veh2->myState.myPos;
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::vsafe( double speed,
                  double decel,
                  double gap2pred,
                  double predSpeed ) const
{
    // Calculate the Stefan Krauss (SK) vsafe.

	if(predSpeed==0&&gap2pred<0.01) { // !!!
		return 0;
	}
    assert( speed     >= double(0) );
    assert( gap2pred  >= double(0) );
    assert( predSpeed >= double(0) );
//if(gap2pred<double(0.01)) {
    double vsafe = predSpeed +
        ( ( gap2pred - predSpeed * myTau ) /
          ( ( ( predSpeed + speed ) * myType->inversTwoDecel() ) + myTau ) );
    assert( vsafe >= 0 );

    return vsafe;
/*} else {
    double vsafe = predSpeed +
        ( ( gap2pred - 0.01 - predSpeed * myTau ) /
          ( ( ( predSpeed + speed ) * myType->inversTwoDecel() ) + myTau ) );
    assert( vsafe >= 0 );

    return vsafe;
}*/

// This assertion has not the intended meaning because of doubleing inaccuracy.
//    assert( vsafe <= gap2pred ); // Collision-free condition.
// This is not the solution, because vsafe allows this vehicle to overlap at
// time t+1 with pred at time t.
//    assert( vsafe <= gap2pred + 0.01 );
}

/////////////////////////////////////////////////////////////////////////////

inline
double
MSVehicle::vMin( double v1, double v2, double v3, double v4 ) const
{
    return min( min( v1, v2 ), min ( v3, v4 ) );
}

/////////////////////////////////////////////////////////////////////////////

inline
bool
MSVehicle::congested()
{
    return myState.mySpeed < double(60) / double(3.6);
}

/////////////////////////////////////////////////////////////////////////////

inline double
MSVehicle::timeHeadWayGap( double speed ) const
{
    assert( speed >= 0 );
    return speed * MSNet::deltaT();
}

/////////////////////////////////////////////////////////////////////////////

inline double
MSVehicle::gap2pred( const MSVehicle& pred ) const
{
    double gap = pred.pos() - pred.length() - this->pos();
    assert( gap >= double( 0 ) );
    return gap;
}

/////////////////////////////////////////////////////////////////////////////

inline double
MSVehicle::gap2predSec( const MSVehicle& pred ) const
{
    return pred.pos() - pred.length() - this->pos();
}

/////////////////////////////////////////////////////////////////////////////

#ifdef DISABLE_INLINE
#undef inline
#endif

// Local Variables:
// mode:C++
// End:


