#ifndef MS_E2_ZS_CollectorOverLanes_h
#define MS_E2_ZS_CollectorOverLanes_h
//---------------------------------------------------------------------------//
//                        MS_E2_ZS_CollectorOverLanes.h -
//  A detector which joins E2Collectors over consecutive lanes (backward)
//                           -------------------
//  project              : SUMO - Simulation of Urban MObility
//  begin                : Oct 2003
//  copyright            : (C) 2003 by Daniel Krajzewicz
//  organisation         : IVF/DLR http://ivf.dlr.de
//  email                : Daniel.Krajzewicz@dlr.de
//---------------------------------------------------------------------------//

//---------------------------------------------------------------------------//
//
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation; either version 2 of the License, or
//   (at your option) any later version.
//
//---------------------------------------------------------------------------//
// $Log$
// Revision 1.5  2004/01/12 14:35:10  dkrajzew
// documentation added; allowed the writing to files
//
//
/* =========================================================================
 * included modules
 * ======================================================================= */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif // HAVE_CONFIG_H

#include "MSE2Collector.h"


/* =========================================================================
 * class definitions
 * ======================================================================= */
/**
 * @class MS_E2_ZS_CollectorOverLanes
 * This class is somekind of a wrapper over several MSE2Collectors.
 * For some reasons it may be necessary to use MSE2Collectors that are
 *  longer than the lane they begin at. In this case, this class should be
 *  used. MSE2Collectors are laid on consecutive lanes backwards, building
 *  a virtual detector for each lane combination.
 * There are still some problems with it: we do not know how the different
 *  combinations shall be treated. Really verified is only the
 *  CURRENT_HALTING_DURATION_SUM_PER_VEHICLE-detector.
 */
class MS_E2_ZS_CollectorOverLanes :
    public MSDetectorFileOutput
{
public:
	/// Definition of a E2-collector storage
    typedef std::vector< MSE2Collector* > CollectorCont;

	/// !!!
    typedef std::map<std::string, std::vector<std::string> > LaneContinuations;

	/// Constructor
    MS_E2_ZS_CollectorOverLanes( std::string id,
                        MSLane* lane,
                        MSUnit::Meters startPos,
                        MSUnit::Seconds haltingTimeThreshold = 1,
                        MSUnit::MetersPerSecond haltingSpeedThreshold =5.0/3.6,
                        MSUnit::Meters jamDistThreshold = 10,
                        MSUnit::Seconds deleteDataAfterSeconds = 1800 );

	/** @brief Builds the consecutive E2-detectors
		This is not done within the constructor to allow overriding of
		most functions but the building of detectors itself which in fact
		is depending on whether the normal or the gui-version is used */
    void init(MSLane *lane, MSUnit::Meters detLength,
        const LaneContinuations &laneContinuations);

	/// Destructor
    virtual ~MS_E2_ZS_CollectorOverLanes( void );

	/// Returns this detector's current value for the measure of the given type
    double getCurrent( E2::DetType type );

	/// Returns this detector's aggregated value for the given measure
    double getAggregate( E2::DetType type, MSUnit::Seconds lastNSeconds );

	/// Returns the information whether the given type is computed
    bool hasDetector( E2::DetType type );

	/// Adds the measure of the given type
    void addDetector( E2::DetType type, std::string detId = "" );

	/// Returns this detector's id
    const std::string &getId() const;

	/// Returns the id of the lane this detector starts at
    const std::string &getStartLaneID() const;

	/// ... have to override this method
    void resetQueueLengthAheadOfTrafficLights( void );


    /**
     * @name Inherited MSDetectorFileOutput methods.
     *
     */
    //@{
    /**
     * Returns a string indentifying an object of this class. Used for
     * distinct filenames.
     */
    std::string  getNamePrefix( void ) const
        {
            return std::string("MS_E2_ZS_CollectorOverLanes");
        }

    /**
     * Get a header for file output which shall contain some
     * explanation of the output generated by getXMLOutput.
     */
    std::string& getXMLHeader( void ) const
        {
            return xmlHeaderM;
        }

    /**
     * Get the XML-formatted output of the concrete detector.
     *
     * @param lastNTimesteps Generate data out of the interval
     * (now-lastNTimesteps, now].
     */
    std::string getXMLOutput( MSUnit::IntSteps lastNTimesteps );

    /**
     * Get an opening XML-element containing information about the detector.
     */
    std::string  getXMLDetectorInfoStart( void ) const;

    /**
     * Get the data-clean up interval in timesteps.
     */
    MSUnit::IntSteps getDataCleanUpSteps( void ) const
        {
            return MSUnit::getInstance()->getIntegerSteps(
                deleteDataAfterSecondsM );
        }
    //@}

	/// Returns this detector's length
    MSUnit::Meters getLength() const {
        return myLength;
    }

protected:
	/** @brief This method extends the current length up to the given
		This method is called consecutively until all paths have the
		desired length */
    void extendTo(double length,
		const LaneContinuations &laneContinuations);

	/// Builds an id for one of the E2-collectors this detector uses
    std::string  makeID( const std::string &baseID,
        size_t c, size_t r ) const;

	/// Builds a single E2-collector
    virtual MSE2Collector *buildCollector(size_t c, size_t r,
        MSLane *l, double start, double end);


protected:
	/// The position the collector starts at
    MSUnit::Meters startPosM;

	/// The length of the collector
    MSUnit::Meters myLength;

	/// The information for how many seconds data shall be saved
    MSUnit::Seconds deleteDataAfterSecondsM;

	/// Describes how long a vehicle shall stay before being assigned to a jam
    MSUnit::Steps haltingTimeThresholdM;

	/// Describes how slow a vehicle must be before being assigned to a jam
    MSUnit::CellsPerStep haltingSpeedThresholdM;

	/// Describes how long a jam must be before being recognized
    MSUnit::Cells jamDistThresholdM;

	/// Definition of a lane storage
    typedef std::vector<MSLane*> LaneVector;

	/// Definition of a storage for lane vectors
    typedef std::vector<LaneVector> LaneVectorVector;

	/// Definition of a detector storage
    typedef std::vector<MSE2Collector*> DetectorVector;

	/// Definition of astorage for detector vectors
    typedef std::vector<DetectorVector> DetectorVectorVector;

	/// Definition of a double storage
    typedef std::vector<double> DoubleVector;

	/// Definition of a storage for double vectors
    typedef DoubleVector LengthVector;

	/** @brief Storage for lane combinations
		Each lane combination is a vector of consecutive lanes (backwards) */
    LaneVectorVector myLaneCombinations;

	/** @brief Storage for detector combinations
		Each detector combination is a vector of consecutive lanes (backwards) */
    DetectorVectorVector myDetectorCombinations;
	/** @brief Storage for length combinations
		Each length combination is a vector of consecutive lanes (backwards) */
    LengthVector myLengths;

	/// The string that is printed in front of the output file
    static std::string xmlHeaderM;

	/// The id of this detector
    std::string myID;

	/// The id of the lane this detector starts at
    std::string myStartLaneID;

	/// Definition of a map from a lane to the detector lying on it
    typedef std::map<MSLane*, MSE2Collector*> LaneDetMap;

	/// Storage for detectors which already have been build for a single lane
    LaneDetMap myAlreadyBuild;

};

/**************** DO NOT DEFINE ANYTHING AFTER THE INCLUDE *****************/

#endif

// Local Variables:
// mode:C++
// End:

