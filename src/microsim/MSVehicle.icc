/***************************************************************************
                          MSVehicle.icc  -  Base for all
                          micro-simulation Vehicles.
                             -------------------
    begin                : Mon, 05 Mar 2001
    copyright            : (C) 2001 by ZAIK http://www.zaik.uni-koeln.de/AFS
    author               : Christian Roessel
    email                : roessel@zpr.uni-koeln.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

// $Log$
// Revision 1.14  2005/10/07 11:37:45  dkrajzew
// THIRD LARGE CODE RECHECK: patched problems on Linux/Windows configs
//
// Revision 1.13  2005/09/22 13:45:51  dkrajzew
// SECOND LARGE CODE RECHECK: converted doubles and floats to SUMOReal
//
// Revision 1.12  2005/09/15 11:10:46  dkrajzew
// LARGE CODE RECHECK
//
// Revision 1.11  2005/05/04 08:34:41  dkrajzew
// level 3 warnings removed; a certain SUMOTime time description added; new mead data functionality; lane-changing offset computation debugged; simulation speed-up by avoiding multiplication with 1
//
// Revision 1.10  2005/02/17 10:33:38  dkrajzew
// code beautifying;
// Linux building patched;
// warnings removed;
// new configuration usage within guisim
//
// Revision 1.9  2004/08/02 12:40:55  dkrajzew
// debugging; refactoring; lane-changing API
//
// Revision 1.8  2004/03/19 13:09:40  dkrajzew
// debugging
//
// Revision 1.7  2003/10/17 06:52:01  dkrajzew
// acceleration is now time-dependent
//
// Revision 1.6  2003/08/20 11:44:11  dkrajzew
// min and max-functions moved to an own definition file
//
// Revision 1.5  2003/04/10 15:43:44  dkrajzew
// emission on non-source lanes debugged
//
// Revision 1.4  2003/04/07 12:12:39  dkrajzew
// eps reduced for small segments (dawdle2)
//
// Revision 1.3  2003/02/07 10:41:50  dkrajzew
// updated
//
// Revision 1.2  2002/10/16 16:45:42  dkrajzew
// debugged
//
// Revision 1.1  2002/10/16 14:48:26  dkrajzew
// ROOT/sumo moved to ROOT/src
//
// Revision 1.3  2002/07/31 17:33:01  roessel
// Changes since sourceforge cvs request.
//
// Revision 1.4  2002/07/31 14:42:34  croessel
// Use of new VehicleType methods.
//
// Revision 1.3  2002/07/03 16:00:22  croessel
// New method gap2pred.
//
// Revision 1.2  2002/06/19 15:07:54  croessel
// Added method timeHeadWayGap( speed ) to forbid timeheadway < deltaT states.
//
// Revision 1.1  2002/05/29 17:09:22  croessel
// Initial commit.
//

/**************** INCLUDE HEADER FILES HERE ********************************/


#ifdef HAVE_CONFIG_H
#ifdef WIN32
#include <windows_config.h>
#else
#include <config.h>
#endif
#endif // HAVE_CONFIG_H

#include "MSLane.h"
#include "MSEdge.h"
#include "MSVehicleType.h"
#include "MSNet.h"
#include <utils/common/StdDefs.h>
#include <iostream>
#include <cassert>
#include <cmath>
#include <cstdlib>
#include <algorithm>


/**************** DO NOT INCLUDE ANYTHING AFTER THIS POINT *****************/
#ifdef DISABLE_INLINE
#define inline
#endif

/**************** DEFINE INLINE FUNCTIONS HERE *****************************/

inline
SUMOReal
MSVehicle::dawdle( SUMOReal speed ) const
{
    // generate random number out of [0,1]
    SUMOReal random = SUMOReal( rand() ) / SUMOReal( RAND_MAX );

    // Dawdle.
    // TODO:
    // We already have a safe speed, if we dawdle max, is it possible
    // to reduce the speed 2*decel?
    speed -= myType->dawdle() * myType->accelSpeed(speed) * random;

    return MAX2( SUMOReal( 0 ), speed );
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::dawdle2( SUMOReal speed ) const
{
    // generate random number out of [0,1]
    SUMOReal random = SUMOReal( rand() ) / SUMOReal( RAND_MAX );

    // Dawdle.
    // TODO:
    // We already have a safe speed, if we dawdle max, is it possible
    // to reduce the speed 2*decel?
    speed -= myType->dawdle() * speed * random;

    return MAX2( SUMOReal( 0 ), speed );
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::tau()
{
    return myTau;
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::pos() const
{
    return myState.myPos;
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::length() const
{
    return myType->length();
}

/////////////////////////////////////////////////////////////////////////////

inline
bool
MSVehicle::overlap( const MSVehicle* veh1, const MSVehicle* veh2 )
{
    if ( veh1->myState.myPos < veh2->myState.myPos ) {

        return veh2->myState.myPos - veh2->myType->myLength <
               veh1->myState.myPos;
    }
    return veh1->myState.myPos - veh1->myType->myLength <
           veh2->myState.myPos;
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::vsafe( SUMOReal speed,
                  SUMOReal decel,
                  SUMOReal gap2pred,
                  SUMOReal predSpeed ) const
{
    // Calculate the Stefan Krauss (SK) vsafe.

    if(predSpeed==0&&gap2pred<0.01) { // !!!
        return 0;
    }
    assert( speed     >= SUMOReal(0) );
    assert( gap2pred  >= SUMOReal(0) );
    assert( predSpeed >= SUMOReal(0) );
//if(gap2pred<SUMOReal(0.01)) {
    SUMOReal vsafe = predSpeed +
        ( ( gap2pred - predSpeed * myTau ) /
          ( ( ( predSpeed + speed ) * myType->inversTwoDecel() ) + myTau ) );
    assert( vsafe >= 0 );

    return vsafe;
/*} else {
    SUMOReal vsafe = predSpeed +
        ( ( gap2pred - 0.01 - predSpeed * myTau ) /
          ( ( ( predSpeed + speed ) * myType->inversTwoDecel() ) + myTau ) );
    assert( vsafe >= 0 );

    return vsafe;
}*/

// This assertion has not the intended meaning because of SUMORealing inaccuracy.
//    assert( vsafe <= gap2pred ); // Collision-free condition.
// This is not the solution, because vsafe allows this vehicle to overlap at
// time t+1 with pred at time t.
//    assert( vsafe <= gap2pred + 0.01 );
}

/////////////////////////////////////////////////////////////////////////////

inline
SUMOReal
MSVehicle::vMin( SUMOReal v1, SUMOReal v2, SUMOReal v3, SUMOReal v4 ) const
{
    return MIN4(v1,v2,v3,v4);
}

/////////////////////////////////////////////////////////////////////////////

inline
bool
MSVehicle::congested() const
{
    return myState.mySpeed < SUMOReal(60) / SUMOReal(3.6);
}

/////////////////////////////////////////////////////////////////////////////

inline SUMOReal
MSVehicle::timeHeadWayGap( SUMOReal speed ) const
{
    assert( speed >= 0 );
    return SPEED2DIST(speed);
}

/////////////////////////////////////////////////////////////////////////////

inline SUMOReal
MSVehicle::gap2pred( const MSVehicle& pred ) const
{
    SUMOReal gap = pred.pos() - pred.length() - this->pos();
    if(gap<0&&gap>-1.0e-12) {
        gap = 0;
    }
    assert( gap >= SUMOReal( 0 ) );
    return gap;
}

/////////////////////////////////////////////////////////////////////////////

inline SUMOReal
MSVehicle::gap2predSec( const MSVehicle& pred ) const
{
    return pred.pos() - pred.length() - this->pos();
}

/////////////////////////////////////////////////////////////////////////////

#ifdef DISABLE_INLINE
#undef inline
#endif

// Local Variables:
// mode:C++
// End:


